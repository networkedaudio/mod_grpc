// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: fs.proto
#ifndef GRPC_fs_2eproto__INCLUDED
#define GRPC_fs_2eproto__INCLUDED

#include "fs.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace fs {

class Api final {
 public:
  static constexpr char const* service_full_name() {
    return "fs.Api";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Originate(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::fs::OriginateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::OriginateResponse>> AsyncOriginate(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::OriginateResponse>>(AsyncOriginateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::OriginateResponse>> PrepareAsyncOriginate(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::OriginateResponse>>(PrepareAsyncOriginateRaw(context, request, cq));
    }
    virtual ::grpc::Status Execute(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::fs::ExecuteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::ExecuteResponse>> AsyncExecute(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::ExecuteResponse>>(AsyncExecuteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::ExecuteResponse>> PrepareAsyncExecute(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::ExecuteResponse>>(PrepareAsyncExecuteRaw(context, request, cq));
    }
    virtual ::grpc::Status SetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::fs::SetVariablesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetVariablesResponse>> AsyncSetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetVariablesResponse>>(AsyncSetVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetVariablesResponse>> PrepareAsyncSetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetVariablesResponse>>(PrepareAsyncSetVariablesRaw(context, request, cq));
    }
    virtual ::grpc::Status Bridge(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::fs::BridgeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeResponse>> AsyncBridge(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeResponse>>(AsyncBridgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeResponse>> PrepareAsyncBridge(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeResponse>>(PrepareAsyncBridgeRaw(context, request, cq));
    }
    virtual ::grpc::Status BridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::fs::BridgeCallResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeCallResponse>> AsyncBridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeCallResponse>>(AsyncBridgeCallRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeCallResponse>> PrepareAsyncBridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeCallResponse>>(PrepareAsyncBridgeCallRaw(context, request, cq));
    }
    virtual ::grpc::Status StopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::fs::StopPlaybackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::StopPlaybackResponse>> AsyncStopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::StopPlaybackResponse>>(AsyncStopPlaybackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::StopPlaybackResponse>> PrepareAsyncStopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::StopPlaybackResponse>>(PrepareAsyncStopPlaybackRaw(context, request, cq));
    }
    virtual ::grpc::Status Hangup(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::fs::HangupResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupResponse>> AsyncHangup(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupResponse>>(AsyncHangupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupResponse>> PrepareAsyncHangup(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupResponse>>(PrepareAsyncHangupRaw(context, request, cq));
    }
    virtual ::grpc::Status HangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::fs::HangupMatchingVarsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupMatchingVarsResponse>> AsyncHangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupMatchingVarsResponse>>(AsyncHangupMatchingVarsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupMatchingVarsResponse>> PrepareAsyncHangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupMatchingVarsResponse>>(PrepareAsyncHangupMatchingVarsRaw(context, request, cq));
    }
    virtual ::grpc::Status Queue(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::fs::QueueResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::QueueResponse>> AsyncQueue(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::QueueResponse>>(AsyncQueueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::QueueResponse>> PrepareAsyncQueue(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::QueueResponse>>(PrepareAsyncQueueRaw(context, request, cq));
    }
    virtual ::grpc::Status HangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::fs::HangupManyResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupManyResponse>> AsyncHangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupManyResponse>>(AsyncHangupManyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupManyResponse>> PrepareAsyncHangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupManyResponse>>(PrepareAsyncHangupManyRaw(context, request, cq));
    }
    virtual ::grpc::Status Hold(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::fs::HoldResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HoldResponse>> AsyncHold(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HoldResponse>>(AsyncHoldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HoldResponse>> PrepareAsyncHold(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::HoldResponse>>(PrepareAsyncHoldRaw(context, request, cq));
    }
    virtual ::grpc::Status UnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::fs::UnHoldResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::UnHoldResponse>> AsyncUnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::UnHoldResponse>>(AsyncUnHoldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::UnHoldResponse>> PrepareAsyncUnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::UnHoldResponse>>(PrepareAsyncUnHoldRaw(context, request, cq));
    }
    virtual ::grpc::Status SetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::fs::SetProfileVarResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetProfileVarResponse>> AsyncSetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetProfileVarResponse>>(AsyncSetProfileVarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetProfileVarResponse>> PrepareAsyncSetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetProfileVarResponse>>(PrepareAsyncSetProfileVarRaw(context, request, cq));
    }
    virtual ::grpc::Status ConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::fs::ConfirmPushResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::ConfirmPushResponse>> AsyncConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::ConfirmPushResponse>>(AsyncConfirmPushRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::ConfirmPushResponse>> PrepareAsyncConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::ConfirmPushResponse>>(PrepareAsyncConfirmPushRaw(context, request, cq));
    }
    virtual ::grpc::Status Broadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::fs::BroadcastResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BroadcastResponse>> AsyncBroadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BroadcastResponse>>(AsyncBroadcastRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BroadcastResponse>> PrepareAsyncBroadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BroadcastResponse>>(PrepareAsyncBroadcastRaw(context, request, cq));
    }
    virtual ::grpc::Status SetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::fs::SetEavesdropStateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetEavesdropStateResponse>> AsyncSetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetEavesdropStateResponse>>(AsyncSetEavesdropStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetEavesdropStateResponse>> PrepareAsyncSetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetEavesdropStateResponse>>(PrepareAsyncSetEavesdropStateRaw(context, request, cq));
    }
    virtual ::grpc::Status BlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::fs::BlindTransferResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BlindTransferResponse>> AsyncBlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BlindTransferResponse>>(AsyncBlindTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BlindTransferResponse>> PrepareAsyncBlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BlindTransferResponse>>(PrepareAsyncBlindTransferRaw(context, request, cq));
    }
    virtual ::grpc::Status BreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::fs::BreakParkResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BreakParkResponse>> AsyncBreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BreakParkResponse>>(AsyncBreakParkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BreakParkResponse>> PrepareAsyncBreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::fs::BreakParkResponse>>(PrepareAsyncBreakParkRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void Originate(::grpc::ClientContext* context, const ::fs::OriginateRequest* request, ::fs::OriginateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Originate(::grpc::ClientContext* context, const ::fs::OriginateRequest* request, ::fs::OriginateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Execute(::grpc::ClientContext* context, const ::fs::ExecuteRequest* request, ::fs::ExecuteResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Execute(::grpc::ClientContext* context, const ::fs::ExecuteRequest* request, ::fs::ExecuteResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest* request, ::fs::SetVariablesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest* request, ::fs::SetVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Bridge(::grpc::ClientContext* context, const ::fs::BridgeRequest* request, ::fs::BridgeResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Bridge(::grpc::ClientContext* context, const ::fs::BridgeRequest* request, ::fs::BridgeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest* request, ::fs::BridgeCallResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest* request, ::fs::BridgeCallResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void StopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest* request, ::fs::StopPlaybackResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest* request, ::fs::StopPlaybackResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Hangup(::grpc::ClientContext* context, const ::fs::HangupRequest* request, ::fs::HangupResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Hangup(::grpc::ClientContext* context, const ::fs::HangupRequest* request, ::fs::HangupResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void HangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust* request, ::fs::HangupMatchingVarsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust* request, ::fs::HangupMatchingVarsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Queue(::grpc::ClientContext* context, const ::fs::QueueRequest* request, ::fs::QueueResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Queue(::grpc::ClientContext* context, const ::fs::QueueRequest* request, ::fs::QueueResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void HangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest* request, ::fs::HangupManyResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void HangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest* request, ::fs::HangupManyResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Hold(::grpc::ClientContext* context, const ::fs::HoldRequest* request, ::fs::HoldResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Hold(::grpc::ClientContext* context, const ::fs::HoldRequest* request, ::fs::HoldResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest* request, ::fs::UnHoldResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest* request, ::fs::UnHoldResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest* request, ::fs::SetProfileVarResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest* request, ::fs::SetProfileVarResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest* request, ::fs::ConfirmPushResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest* request, ::fs::ConfirmPushResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Broadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest* request, ::fs::BroadcastResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Broadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest* request, ::fs::BroadcastResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void SetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest* request, ::fs::SetEavesdropStateResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void SetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest* request, ::fs::SetEavesdropStateResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest* request, ::fs::BlindTransferResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest* request, ::fs::BlindTransferResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void BreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest* request, ::fs::BreakParkResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void BreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest* request, ::fs::BreakParkResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::OriginateResponse>* AsyncOriginateRaw(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::OriginateResponse>* PrepareAsyncOriginateRaw(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::ExecuteResponse>* AsyncExecuteRaw(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::ExecuteResponse>* PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetVariablesResponse>* AsyncSetVariablesRaw(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetVariablesResponse>* PrepareAsyncSetVariablesRaw(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeResponse>* AsyncBridgeRaw(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeResponse>* PrepareAsyncBridgeRaw(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeCallResponse>* AsyncBridgeCallRaw(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BridgeCallResponse>* PrepareAsyncBridgeCallRaw(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::StopPlaybackResponse>* AsyncStopPlaybackRaw(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::StopPlaybackResponse>* PrepareAsyncStopPlaybackRaw(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupResponse>* AsyncHangupRaw(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupResponse>* PrepareAsyncHangupRaw(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupMatchingVarsResponse>* AsyncHangupMatchingVarsRaw(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupMatchingVarsResponse>* PrepareAsyncHangupMatchingVarsRaw(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::QueueResponse>* AsyncQueueRaw(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::QueueResponse>* PrepareAsyncQueueRaw(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupManyResponse>* AsyncHangupManyRaw(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::HangupManyResponse>* PrepareAsyncHangupManyRaw(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::HoldResponse>* AsyncHoldRaw(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::HoldResponse>* PrepareAsyncHoldRaw(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::UnHoldResponse>* AsyncUnHoldRaw(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::UnHoldResponse>* PrepareAsyncUnHoldRaw(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetProfileVarResponse>* AsyncSetProfileVarRaw(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetProfileVarResponse>* PrepareAsyncSetProfileVarRaw(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::ConfirmPushResponse>* AsyncConfirmPushRaw(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::ConfirmPushResponse>* PrepareAsyncConfirmPushRaw(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BroadcastResponse>* AsyncBroadcastRaw(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BroadcastResponse>* PrepareAsyncBroadcastRaw(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetEavesdropStateResponse>* AsyncSetEavesdropStateRaw(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::SetEavesdropStateResponse>* PrepareAsyncSetEavesdropStateRaw(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BlindTransferResponse>* AsyncBlindTransferRaw(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BlindTransferResponse>* PrepareAsyncBlindTransferRaw(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BreakParkResponse>* AsyncBreakParkRaw(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::fs::BreakParkResponse>* PrepareAsyncBreakParkRaw(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Originate(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::fs::OriginateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::OriginateResponse>> AsyncOriginate(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::OriginateResponse>>(AsyncOriginateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::OriginateResponse>> PrepareAsyncOriginate(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::OriginateResponse>>(PrepareAsyncOriginateRaw(context, request, cq));
    }
    ::grpc::Status Execute(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::fs::ExecuteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::ExecuteResponse>> AsyncExecute(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::ExecuteResponse>>(AsyncExecuteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::ExecuteResponse>> PrepareAsyncExecute(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::ExecuteResponse>>(PrepareAsyncExecuteRaw(context, request, cq));
    }
    ::grpc::Status SetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::fs::SetVariablesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetVariablesResponse>> AsyncSetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetVariablesResponse>>(AsyncSetVariablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetVariablesResponse>> PrepareAsyncSetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetVariablesResponse>>(PrepareAsyncSetVariablesRaw(context, request, cq));
    }
    ::grpc::Status Bridge(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::fs::BridgeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BridgeResponse>> AsyncBridge(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BridgeResponse>>(AsyncBridgeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BridgeResponse>> PrepareAsyncBridge(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BridgeResponse>>(PrepareAsyncBridgeRaw(context, request, cq));
    }
    ::grpc::Status BridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::fs::BridgeCallResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BridgeCallResponse>> AsyncBridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BridgeCallResponse>>(AsyncBridgeCallRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BridgeCallResponse>> PrepareAsyncBridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BridgeCallResponse>>(PrepareAsyncBridgeCallRaw(context, request, cq));
    }
    ::grpc::Status StopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::fs::StopPlaybackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::StopPlaybackResponse>> AsyncStopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::StopPlaybackResponse>>(AsyncStopPlaybackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::StopPlaybackResponse>> PrepareAsyncStopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::StopPlaybackResponse>>(PrepareAsyncStopPlaybackRaw(context, request, cq));
    }
    ::grpc::Status Hangup(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::fs::HangupResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupResponse>> AsyncHangup(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupResponse>>(AsyncHangupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupResponse>> PrepareAsyncHangup(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupResponse>>(PrepareAsyncHangupRaw(context, request, cq));
    }
    ::grpc::Status HangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::fs::HangupMatchingVarsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupMatchingVarsResponse>> AsyncHangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupMatchingVarsResponse>>(AsyncHangupMatchingVarsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupMatchingVarsResponse>> PrepareAsyncHangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupMatchingVarsResponse>>(PrepareAsyncHangupMatchingVarsRaw(context, request, cq));
    }
    ::grpc::Status Queue(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::fs::QueueResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::QueueResponse>> AsyncQueue(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::QueueResponse>>(AsyncQueueRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::QueueResponse>> PrepareAsyncQueue(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::QueueResponse>>(PrepareAsyncQueueRaw(context, request, cq));
    }
    ::grpc::Status HangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::fs::HangupManyResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupManyResponse>> AsyncHangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupManyResponse>>(AsyncHangupManyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupManyResponse>> PrepareAsyncHangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HangupManyResponse>>(PrepareAsyncHangupManyRaw(context, request, cq));
    }
    ::grpc::Status Hold(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::fs::HoldResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HoldResponse>> AsyncHold(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HoldResponse>>(AsyncHoldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HoldResponse>> PrepareAsyncHold(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::HoldResponse>>(PrepareAsyncHoldRaw(context, request, cq));
    }
    ::grpc::Status UnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::fs::UnHoldResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::UnHoldResponse>> AsyncUnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::UnHoldResponse>>(AsyncUnHoldRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::UnHoldResponse>> PrepareAsyncUnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::UnHoldResponse>>(PrepareAsyncUnHoldRaw(context, request, cq));
    }
    ::grpc::Status SetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::fs::SetProfileVarResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetProfileVarResponse>> AsyncSetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetProfileVarResponse>>(AsyncSetProfileVarRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetProfileVarResponse>> PrepareAsyncSetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetProfileVarResponse>>(PrepareAsyncSetProfileVarRaw(context, request, cq));
    }
    ::grpc::Status ConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::fs::ConfirmPushResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::ConfirmPushResponse>> AsyncConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::ConfirmPushResponse>>(AsyncConfirmPushRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::ConfirmPushResponse>> PrepareAsyncConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::ConfirmPushResponse>>(PrepareAsyncConfirmPushRaw(context, request, cq));
    }
    ::grpc::Status Broadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::fs::BroadcastResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BroadcastResponse>> AsyncBroadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BroadcastResponse>>(AsyncBroadcastRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BroadcastResponse>> PrepareAsyncBroadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BroadcastResponse>>(PrepareAsyncBroadcastRaw(context, request, cq));
    }
    ::grpc::Status SetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::fs::SetEavesdropStateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetEavesdropStateResponse>> AsyncSetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetEavesdropStateResponse>>(AsyncSetEavesdropStateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetEavesdropStateResponse>> PrepareAsyncSetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::SetEavesdropStateResponse>>(PrepareAsyncSetEavesdropStateRaw(context, request, cq));
    }
    ::grpc::Status BlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::fs::BlindTransferResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BlindTransferResponse>> AsyncBlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BlindTransferResponse>>(AsyncBlindTransferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BlindTransferResponse>> PrepareAsyncBlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BlindTransferResponse>>(PrepareAsyncBlindTransferRaw(context, request, cq));
    }
    ::grpc::Status BreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::fs::BreakParkResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BreakParkResponse>> AsyncBreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BreakParkResponse>>(AsyncBreakParkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BreakParkResponse>> PrepareAsyncBreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::fs::BreakParkResponse>>(PrepareAsyncBreakParkRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void Originate(::grpc::ClientContext* context, const ::fs::OriginateRequest* request, ::fs::OriginateResponse* response, std::function<void(::grpc::Status)>) override;
      void Originate(::grpc::ClientContext* context, const ::fs::OriginateRequest* request, ::fs::OriginateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Execute(::grpc::ClientContext* context, const ::fs::ExecuteRequest* request, ::fs::ExecuteResponse* response, std::function<void(::grpc::Status)>) override;
      void Execute(::grpc::ClientContext* context, const ::fs::ExecuteRequest* request, ::fs::ExecuteResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest* request, ::fs::SetVariablesResponse* response, std::function<void(::grpc::Status)>) override;
      void SetVariables(::grpc::ClientContext* context, const ::fs::SetVariablesRequest* request, ::fs::SetVariablesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Bridge(::grpc::ClientContext* context, const ::fs::BridgeRequest* request, ::fs::BridgeResponse* response, std::function<void(::grpc::Status)>) override;
      void Bridge(::grpc::ClientContext* context, const ::fs::BridgeRequest* request, ::fs::BridgeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest* request, ::fs::BridgeCallResponse* response, std::function<void(::grpc::Status)>) override;
      void BridgeCall(::grpc::ClientContext* context, const ::fs::BridgeCallRequest* request, ::fs::BridgeCallResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void StopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest* request, ::fs::StopPlaybackResponse* response, std::function<void(::grpc::Status)>) override;
      void StopPlayback(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest* request, ::fs::StopPlaybackResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Hangup(::grpc::ClientContext* context, const ::fs::HangupRequest* request, ::fs::HangupResponse* response, std::function<void(::grpc::Status)>) override;
      void Hangup(::grpc::ClientContext* context, const ::fs::HangupRequest* request, ::fs::HangupResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust* request, ::fs::HangupMatchingVarsResponse* response, std::function<void(::grpc::Status)>) override;
      void HangupMatchingVars(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust* request, ::fs::HangupMatchingVarsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Queue(::grpc::ClientContext* context, const ::fs::QueueRequest* request, ::fs::QueueResponse* response, std::function<void(::grpc::Status)>) override;
      void Queue(::grpc::ClientContext* context, const ::fs::QueueRequest* request, ::fs::QueueResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void HangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest* request, ::fs::HangupManyResponse* response, std::function<void(::grpc::Status)>) override;
      void HangupMany(::grpc::ClientContext* context, const ::fs::HangupManyRequest* request, ::fs::HangupManyResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Hold(::grpc::ClientContext* context, const ::fs::HoldRequest* request, ::fs::HoldResponse* response, std::function<void(::grpc::Status)>) override;
      void Hold(::grpc::ClientContext* context, const ::fs::HoldRequest* request, ::fs::HoldResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest* request, ::fs::UnHoldResponse* response, std::function<void(::grpc::Status)>) override;
      void UnHold(::grpc::ClientContext* context, const ::fs::UnHoldRequest* request, ::fs::UnHoldResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest* request, ::fs::SetProfileVarResponse* response, std::function<void(::grpc::Status)>) override;
      void SetProfileVar(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest* request, ::fs::SetProfileVarResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest* request, ::fs::ConfirmPushResponse* response, std::function<void(::grpc::Status)>) override;
      void ConfirmPush(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest* request, ::fs::ConfirmPushResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Broadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest* request, ::fs::BroadcastResponse* response, std::function<void(::grpc::Status)>) override;
      void Broadcast(::grpc::ClientContext* context, const ::fs::BroadcastRequest* request, ::fs::BroadcastResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void SetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest* request, ::fs::SetEavesdropStateResponse* response, std::function<void(::grpc::Status)>) override;
      void SetEavesdropState(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest* request, ::fs::SetEavesdropStateResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest* request, ::fs::BlindTransferResponse* response, std::function<void(::grpc::Status)>) override;
      void BlindTransfer(::grpc::ClientContext* context, const ::fs::BlindTransferRequest* request, ::fs::BlindTransferResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void BreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest* request, ::fs::BreakParkResponse* response, std::function<void(::grpc::Status)>) override;
      void BreakPark(::grpc::ClientContext* context, const ::fs::BreakParkRequest* request, ::fs::BreakParkResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::fs::OriginateResponse>* AsyncOriginateRaw(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::OriginateResponse>* PrepareAsyncOriginateRaw(::grpc::ClientContext* context, const ::fs::OriginateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::ExecuteResponse>* AsyncExecuteRaw(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::ExecuteResponse>* PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::fs::ExecuteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::SetVariablesResponse>* AsyncSetVariablesRaw(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::SetVariablesResponse>* PrepareAsyncSetVariablesRaw(::grpc::ClientContext* context, const ::fs::SetVariablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BridgeResponse>* AsyncBridgeRaw(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BridgeResponse>* PrepareAsyncBridgeRaw(::grpc::ClientContext* context, const ::fs::BridgeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BridgeCallResponse>* AsyncBridgeCallRaw(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BridgeCallResponse>* PrepareAsyncBridgeCallRaw(::grpc::ClientContext* context, const ::fs::BridgeCallRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::StopPlaybackResponse>* AsyncStopPlaybackRaw(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::StopPlaybackResponse>* PrepareAsyncStopPlaybackRaw(::grpc::ClientContext* context, const ::fs::StopPlaybackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::HangupResponse>* AsyncHangupRaw(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::HangupResponse>* PrepareAsyncHangupRaw(::grpc::ClientContext* context, const ::fs::HangupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::HangupMatchingVarsResponse>* AsyncHangupMatchingVarsRaw(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::HangupMatchingVarsResponse>* PrepareAsyncHangupMatchingVarsRaw(::grpc::ClientContext* context, const ::fs::HangupMatchingVarsReqeust& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::QueueResponse>* AsyncQueueRaw(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::QueueResponse>* PrepareAsyncQueueRaw(::grpc::ClientContext* context, const ::fs::QueueRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::HangupManyResponse>* AsyncHangupManyRaw(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::HangupManyResponse>* PrepareAsyncHangupManyRaw(::grpc::ClientContext* context, const ::fs::HangupManyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::HoldResponse>* AsyncHoldRaw(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::HoldResponse>* PrepareAsyncHoldRaw(::grpc::ClientContext* context, const ::fs::HoldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::UnHoldResponse>* AsyncUnHoldRaw(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::UnHoldResponse>* PrepareAsyncUnHoldRaw(::grpc::ClientContext* context, const ::fs::UnHoldRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::SetProfileVarResponse>* AsyncSetProfileVarRaw(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::SetProfileVarResponse>* PrepareAsyncSetProfileVarRaw(::grpc::ClientContext* context, const ::fs::SetProfileVarRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::ConfirmPushResponse>* AsyncConfirmPushRaw(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::ConfirmPushResponse>* PrepareAsyncConfirmPushRaw(::grpc::ClientContext* context, const ::fs::ConfirmPushRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BroadcastResponse>* AsyncBroadcastRaw(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BroadcastResponse>* PrepareAsyncBroadcastRaw(::grpc::ClientContext* context, const ::fs::BroadcastRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::SetEavesdropStateResponse>* AsyncSetEavesdropStateRaw(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::SetEavesdropStateResponse>* PrepareAsyncSetEavesdropStateRaw(::grpc::ClientContext* context, const ::fs::SetEavesdropStateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BlindTransferResponse>* AsyncBlindTransferRaw(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BlindTransferResponse>* PrepareAsyncBlindTransferRaw(::grpc::ClientContext* context, const ::fs::BlindTransferRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BreakParkResponse>* AsyncBreakParkRaw(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::fs::BreakParkResponse>* PrepareAsyncBreakParkRaw(::grpc::ClientContext* context, const ::fs::BreakParkRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Originate_;
    const ::grpc::internal::RpcMethod rpcmethod_Execute_;
    const ::grpc::internal::RpcMethod rpcmethod_SetVariables_;
    const ::grpc::internal::RpcMethod rpcmethod_Bridge_;
    const ::grpc::internal::RpcMethod rpcmethod_BridgeCall_;
    const ::grpc::internal::RpcMethod rpcmethod_StopPlayback_;
    const ::grpc::internal::RpcMethod rpcmethod_Hangup_;
    const ::grpc::internal::RpcMethod rpcmethod_HangupMatchingVars_;
    const ::grpc::internal::RpcMethod rpcmethod_Queue_;
    const ::grpc::internal::RpcMethod rpcmethod_HangupMany_;
    const ::grpc::internal::RpcMethod rpcmethod_Hold_;
    const ::grpc::internal::RpcMethod rpcmethod_UnHold_;
    const ::grpc::internal::RpcMethod rpcmethod_SetProfileVar_;
    const ::grpc::internal::RpcMethod rpcmethod_ConfirmPush_;
    const ::grpc::internal::RpcMethod rpcmethod_Broadcast_;
    const ::grpc::internal::RpcMethod rpcmethod_SetEavesdropState_;
    const ::grpc::internal::RpcMethod rpcmethod_BlindTransfer_;
    const ::grpc::internal::RpcMethod rpcmethod_BreakPark_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Originate(::grpc::ServerContext* context, const ::fs::OriginateRequest* request, ::fs::OriginateResponse* response);
    virtual ::grpc::Status Execute(::grpc::ServerContext* context, const ::fs::ExecuteRequest* request, ::fs::ExecuteResponse* response);
    virtual ::grpc::Status SetVariables(::grpc::ServerContext* context, const ::fs::SetVariablesRequest* request, ::fs::SetVariablesResponse* response);
    virtual ::grpc::Status Bridge(::grpc::ServerContext* context, const ::fs::BridgeRequest* request, ::fs::BridgeResponse* response);
    virtual ::grpc::Status BridgeCall(::grpc::ServerContext* context, const ::fs::BridgeCallRequest* request, ::fs::BridgeCallResponse* response);
    virtual ::grpc::Status StopPlayback(::grpc::ServerContext* context, const ::fs::StopPlaybackRequest* request, ::fs::StopPlaybackResponse* response);
    virtual ::grpc::Status Hangup(::grpc::ServerContext* context, const ::fs::HangupRequest* request, ::fs::HangupResponse* response);
    virtual ::grpc::Status HangupMatchingVars(::grpc::ServerContext* context, const ::fs::HangupMatchingVarsReqeust* request, ::fs::HangupMatchingVarsResponse* response);
    virtual ::grpc::Status Queue(::grpc::ServerContext* context, const ::fs::QueueRequest* request, ::fs::QueueResponse* response);
    virtual ::grpc::Status HangupMany(::grpc::ServerContext* context, const ::fs::HangupManyRequest* request, ::fs::HangupManyResponse* response);
    virtual ::grpc::Status Hold(::grpc::ServerContext* context, const ::fs::HoldRequest* request, ::fs::HoldResponse* response);
    virtual ::grpc::Status UnHold(::grpc::ServerContext* context, const ::fs::UnHoldRequest* request, ::fs::UnHoldResponse* response);
    virtual ::grpc::Status SetProfileVar(::grpc::ServerContext* context, const ::fs::SetProfileVarRequest* request, ::fs::SetProfileVarResponse* response);
    virtual ::grpc::Status ConfirmPush(::grpc::ServerContext* context, const ::fs::ConfirmPushRequest* request, ::fs::ConfirmPushResponse* response);
    virtual ::grpc::Status Broadcast(::grpc::ServerContext* context, const ::fs::BroadcastRequest* request, ::fs::BroadcastResponse* response);
    virtual ::grpc::Status SetEavesdropState(::grpc::ServerContext* context, const ::fs::SetEavesdropStateRequest* request, ::fs::SetEavesdropStateResponse* response);
    virtual ::grpc::Status BlindTransfer(::grpc::ServerContext* context, const ::fs::BlindTransferRequest* request, ::fs::BlindTransferResponse* response);
    virtual ::grpc::Status BreakPark(::grpc::ServerContext* context, const ::fs::BreakParkRequest* request, ::fs::BreakParkResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Originate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Originate() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Originate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Originate(::grpc::ServerContext* /*context*/, const ::fs::OriginateRequest* /*request*/, ::fs::OriginateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOriginate(::grpc::ServerContext* context, ::fs::OriginateRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::OriginateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Execute() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::fs::ExecuteRequest* /*request*/, ::fs::ExecuteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecute(::grpc::ServerContext* context, ::fs::ExecuteRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::ExecuteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetVariables() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::fs::SetVariablesRequest* /*request*/, ::fs::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVariables(::grpc::ServerContext* context, ::fs::SetVariablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::SetVariablesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Bridge() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bridge(::grpc::ServerContext* /*context*/, const ::fs::BridgeRequest* /*request*/, ::fs::BridgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBridge(::grpc::ServerContext* context, ::fs::BridgeRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::BridgeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BridgeCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BridgeCall() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_BridgeCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BridgeCall(::grpc::ServerContext* /*context*/, const ::fs::BridgeCallRequest* /*request*/, ::fs::BridgeCallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBridgeCall(::grpc::ServerContext* context, ::fs::BridgeCallRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::BridgeCallResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StopPlayback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StopPlayback() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_StopPlayback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPlayback(::grpc::ServerContext* /*context*/, const ::fs::StopPlaybackRequest* /*request*/, ::fs::StopPlaybackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopPlayback(::grpc::ServerContext* context, ::fs::StopPlaybackRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::StopPlaybackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Hangup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Hangup() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_Hangup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hangup(::grpc::ServerContext* /*context*/, const ::fs::HangupRequest* /*request*/, ::fs::HangupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHangup(::grpc::ServerContext* context, ::fs::HangupRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::HangupResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HangupMatchingVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HangupMatchingVars() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_HangupMatchingVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMatchingVars(::grpc::ServerContext* /*context*/, const ::fs::HangupMatchingVarsReqeust* /*request*/, ::fs::HangupMatchingVarsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHangupMatchingVars(::grpc::ServerContext* context, ::fs::HangupMatchingVarsReqeust* request, ::grpc::ServerAsyncResponseWriter< ::fs::HangupMatchingVarsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Queue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Queue() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_Queue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Queue(::grpc::ServerContext* /*context*/, const ::fs::QueueRequest* /*request*/, ::fs::QueueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueue(::grpc::ServerContext* context, ::fs::QueueRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::QueueResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HangupMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HangupMany() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_HangupMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMany(::grpc::ServerContext* /*context*/, const ::fs::HangupManyRequest* /*request*/, ::fs::HangupManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHangupMany(::grpc::ServerContext* context, ::fs::HangupManyRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::HangupManyResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Hold() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::fs::HoldRequest* /*request*/, ::fs::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHold(::grpc::ServerContext* context, ::fs::HoldRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::HoldResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnHold() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_UnHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnHold(::grpc::ServerContext* /*context*/, const ::fs::UnHoldRequest* /*request*/, ::fs::UnHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnHold(::grpc::ServerContext* context, ::fs::UnHoldRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::UnHoldResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetProfileVar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetProfileVar() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_SetProfileVar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVar(::grpc::ServerContext* /*context*/, const ::fs::SetProfileVarRequest* /*request*/, ::fs::SetProfileVarResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProfileVar(::grpc::ServerContext* context, ::fs::SetProfileVarRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::SetProfileVarResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ConfirmPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ConfirmPush() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ConfirmPush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfirmPush(::grpc::ServerContext* /*context*/, const ::fs::ConfirmPushRequest* /*request*/, ::fs::ConfirmPushResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfirmPush(::grpc::ServerContext* context, ::fs::ConfirmPushRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::ConfirmPushResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Broadcast : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Broadcast() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_Broadcast() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Broadcast(::grpc::ServerContext* /*context*/, const ::fs::BroadcastRequest* /*request*/, ::fs::BroadcastResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBroadcast(::grpc::ServerContext* context, ::fs::BroadcastRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::BroadcastResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SetEavesdropState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SetEavesdropState() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_SetEavesdropState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEavesdropState(::grpc::ServerContext* /*context*/, const ::fs::SetEavesdropStateRequest* /*request*/, ::fs::SetEavesdropStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEavesdropState(::grpc::ServerContext* context, ::fs::SetEavesdropStateRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::SetEavesdropStateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BlindTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BlindTransfer() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_BlindTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlindTransfer(::grpc::ServerContext* /*context*/, const ::fs::BlindTransferRequest* /*request*/, ::fs::BlindTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlindTransfer(::grpc::ServerContext* context, ::fs::BlindTransferRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::BlindTransferResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BreakPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_BreakPark() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_BreakPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BreakPark(::grpc::ServerContext* /*context*/, const ::fs::BreakParkRequest* /*request*/, ::fs::BreakParkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBreakPark(::grpc::ServerContext* context, ::fs::BreakParkRequest* request, ::grpc::ServerAsyncResponseWriter< ::fs::BreakParkResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Originate<WithAsyncMethod_Execute<WithAsyncMethod_SetVariables<WithAsyncMethod_Bridge<WithAsyncMethod_BridgeCall<WithAsyncMethod_StopPlayback<WithAsyncMethod_Hangup<WithAsyncMethod_HangupMatchingVars<WithAsyncMethod_Queue<WithAsyncMethod_HangupMany<WithAsyncMethod_Hold<WithAsyncMethod_UnHold<WithAsyncMethod_SetProfileVar<WithAsyncMethod_ConfirmPush<WithAsyncMethod_Broadcast<WithAsyncMethod_SetEavesdropState<WithAsyncMethod_BlindTransfer<WithAsyncMethod_BreakPark<Service > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_Originate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Originate() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::OriginateRequest, ::fs::OriginateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::OriginateRequest* request, ::fs::OriginateResponse* response) { return this->Originate(context, request, response); }));}
    void SetMessageAllocatorFor_Originate(
        ::grpc::MessageAllocator< ::fs::OriginateRequest, ::fs::OriginateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::OriginateRequest, ::fs::OriginateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Originate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Originate(::grpc::ServerContext* /*context*/, const ::fs::OriginateRequest* /*request*/, ::fs::OriginateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Originate(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::OriginateRequest* /*request*/, ::fs::OriginateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Execute() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::ExecuteRequest, ::fs::ExecuteResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::ExecuteRequest* request, ::fs::ExecuteResponse* response) { return this->Execute(context, request, response); }));}
    void SetMessageAllocatorFor_Execute(
        ::grpc::MessageAllocator< ::fs::ExecuteRequest, ::fs::ExecuteResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::ExecuteRequest, ::fs::ExecuteResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::fs::ExecuteRequest* /*request*/, ::fs::ExecuteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Execute(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::ExecuteRequest* /*request*/, ::fs::ExecuteResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetVariables() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::SetVariablesRequest, ::fs::SetVariablesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::SetVariablesRequest* request, ::fs::SetVariablesResponse* response) { return this->SetVariables(context, request, response); }));}
    void SetMessageAllocatorFor_SetVariables(
        ::grpc::MessageAllocator< ::fs::SetVariablesRequest, ::fs::SetVariablesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::SetVariablesRequest, ::fs::SetVariablesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::fs::SetVariablesRequest* /*request*/, ::fs::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::SetVariablesRequest* /*request*/, ::fs::SetVariablesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Bridge() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::BridgeRequest, ::fs::BridgeResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::BridgeRequest* request, ::fs::BridgeResponse* response) { return this->Bridge(context, request, response); }));}
    void SetMessageAllocatorFor_Bridge(
        ::grpc::MessageAllocator< ::fs::BridgeRequest, ::fs::BridgeResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::BridgeRequest, ::fs::BridgeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bridge(::grpc::ServerContext* /*context*/, const ::fs::BridgeRequest* /*request*/, ::fs::BridgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Bridge(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::BridgeRequest* /*request*/, ::fs::BridgeResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BridgeCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BridgeCall() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::BridgeCallRequest, ::fs::BridgeCallResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::BridgeCallRequest* request, ::fs::BridgeCallResponse* response) { return this->BridgeCall(context, request, response); }));}
    void SetMessageAllocatorFor_BridgeCall(
        ::grpc::MessageAllocator< ::fs::BridgeCallRequest, ::fs::BridgeCallResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::BridgeCallRequest, ::fs::BridgeCallResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BridgeCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BridgeCall(::grpc::ServerContext* /*context*/, const ::fs::BridgeCallRequest* /*request*/, ::fs::BridgeCallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BridgeCall(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::BridgeCallRequest* /*request*/, ::fs::BridgeCallResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_StopPlayback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_StopPlayback() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::StopPlaybackRequest, ::fs::StopPlaybackResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::StopPlaybackRequest* request, ::fs::StopPlaybackResponse* response) { return this->StopPlayback(context, request, response); }));}
    void SetMessageAllocatorFor_StopPlayback(
        ::grpc::MessageAllocator< ::fs::StopPlaybackRequest, ::fs::StopPlaybackResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::StopPlaybackRequest, ::fs::StopPlaybackResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_StopPlayback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPlayback(::grpc::ServerContext* /*context*/, const ::fs::StopPlaybackRequest* /*request*/, ::fs::StopPlaybackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopPlayback(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::StopPlaybackRequest* /*request*/, ::fs::StopPlaybackResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Hangup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Hangup() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::HangupRequest, ::fs::HangupResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::HangupRequest* request, ::fs::HangupResponse* response) { return this->Hangup(context, request, response); }));}
    void SetMessageAllocatorFor_Hangup(
        ::grpc::MessageAllocator< ::fs::HangupRequest, ::fs::HangupResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::HangupRequest, ::fs::HangupResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Hangup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hangup(::grpc::ServerContext* /*context*/, const ::fs::HangupRequest* /*request*/, ::fs::HangupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Hangup(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::HangupRequest* /*request*/, ::fs::HangupResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HangupMatchingVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HangupMatchingVars() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::HangupMatchingVarsReqeust, ::fs::HangupMatchingVarsResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::HangupMatchingVarsReqeust* request, ::fs::HangupMatchingVarsResponse* response) { return this->HangupMatchingVars(context, request, response); }));}
    void SetMessageAllocatorFor_HangupMatchingVars(
        ::grpc::MessageAllocator< ::fs::HangupMatchingVarsReqeust, ::fs::HangupMatchingVarsResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::HangupMatchingVarsReqeust, ::fs::HangupMatchingVarsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HangupMatchingVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMatchingVars(::grpc::ServerContext* /*context*/, const ::fs::HangupMatchingVarsReqeust* /*request*/, ::fs::HangupMatchingVarsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HangupMatchingVars(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::HangupMatchingVarsReqeust* /*request*/, ::fs::HangupMatchingVarsResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Queue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Queue() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::QueueRequest, ::fs::QueueResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::QueueRequest* request, ::fs::QueueResponse* response) { return this->Queue(context, request, response); }));}
    void SetMessageAllocatorFor_Queue(
        ::grpc::MessageAllocator< ::fs::QueueRequest, ::fs::QueueResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::QueueRequest, ::fs::QueueResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Queue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Queue(::grpc::ServerContext* /*context*/, const ::fs::QueueRequest* /*request*/, ::fs::QueueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Queue(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::QueueRequest* /*request*/, ::fs::QueueResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_HangupMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_HangupMany() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::HangupManyRequest, ::fs::HangupManyResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::HangupManyRequest* request, ::fs::HangupManyResponse* response) { return this->HangupMany(context, request, response); }));}
    void SetMessageAllocatorFor_HangupMany(
        ::grpc::MessageAllocator< ::fs::HangupManyRequest, ::fs::HangupManyResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::HangupManyRequest, ::fs::HangupManyResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_HangupMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMany(::grpc::ServerContext* /*context*/, const ::fs::HangupManyRequest* /*request*/, ::fs::HangupManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HangupMany(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::HangupManyRequest* /*request*/, ::fs::HangupManyResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Hold() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::HoldRequest, ::fs::HoldResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::HoldRequest* request, ::fs::HoldResponse* response) { return this->Hold(context, request, response); }));}
    void SetMessageAllocatorFor_Hold(
        ::grpc::MessageAllocator< ::fs::HoldRequest, ::fs::HoldResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::HoldRequest, ::fs::HoldResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::fs::HoldRequest* /*request*/, ::fs::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Hold(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::HoldRequest* /*request*/, ::fs::HoldResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UnHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UnHold() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::UnHoldRequest, ::fs::UnHoldResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::UnHoldRequest* request, ::fs::UnHoldResponse* response) { return this->UnHold(context, request, response); }));}
    void SetMessageAllocatorFor_UnHold(
        ::grpc::MessageAllocator< ::fs::UnHoldRequest, ::fs::UnHoldResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::UnHoldRequest, ::fs::UnHoldResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UnHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnHold(::grpc::ServerContext* /*context*/, const ::fs::UnHoldRequest* /*request*/, ::fs::UnHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UnHold(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::UnHoldRequest* /*request*/, ::fs::UnHoldResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetProfileVar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetProfileVar() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::SetProfileVarRequest, ::fs::SetProfileVarResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::SetProfileVarRequest* request, ::fs::SetProfileVarResponse* response) { return this->SetProfileVar(context, request, response); }));}
    void SetMessageAllocatorFor_SetProfileVar(
        ::grpc::MessageAllocator< ::fs::SetProfileVarRequest, ::fs::SetProfileVarResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::SetProfileVarRequest, ::fs::SetProfileVarResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetProfileVar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVar(::grpc::ServerContext* /*context*/, const ::fs::SetProfileVarRequest* /*request*/, ::fs::SetProfileVarResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetProfileVar(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::SetProfileVarRequest* /*request*/, ::fs::SetProfileVarResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ConfirmPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ConfirmPush() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::ConfirmPushRequest, ::fs::ConfirmPushResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::ConfirmPushRequest* request, ::fs::ConfirmPushResponse* response) { return this->ConfirmPush(context, request, response); }));}
    void SetMessageAllocatorFor_ConfirmPush(
        ::grpc::MessageAllocator< ::fs::ConfirmPushRequest, ::fs::ConfirmPushResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::ConfirmPushRequest, ::fs::ConfirmPushResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ConfirmPush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfirmPush(::grpc::ServerContext* /*context*/, const ::fs::ConfirmPushRequest* /*request*/, ::fs::ConfirmPushResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConfirmPush(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::ConfirmPushRequest* /*request*/, ::fs::ConfirmPushResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Broadcast : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Broadcast() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::BroadcastRequest, ::fs::BroadcastResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::BroadcastRequest* request, ::fs::BroadcastResponse* response) { return this->Broadcast(context, request, response); }));}
    void SetMessageAllocatorFor_Broadcast(
        ::grpc::MessageAllocator< ::fs::BroadcastRequest, ::fs::BroadcastResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::BroadcastRequest, ::fs::BroadcastResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Broadcast() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Broadcast(::grpc::ServerContext* /*context*/, const ::fs::BroadcastRequest* /*request*/, ::fs::BroadcastResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Broadcast(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::BroadcastRequest* /*request*/, ::fs::BroadcastResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_SetEavesdropState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SetEavesdropState() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::SetEavesdropStateRequest, ::fs::SetEavesdropStateResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::SetEavesdropStateRequest* request, ::fs::SetEavesdropStateResponse* response) { return this->SetEavesdropState(context, request, response); }));}
    void SetMessageAllocatorFor_SetEavesdropState(
        ::grpc::MessageAllocator< ::fs::SetEavesdropStateRequest, ::fs::SetEavesdropStateResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::SetEavesdropStateRequest, ::fs::SetEavesdropStateResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_SetEavesdropState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEavesdropState(::grpc::ServerContext* /*context*/, const ::fs::SetEavesdropStateRequest* /*request*/, ::fs::SetEavesdropStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEavesdropState(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::SetEavesdropStateRequest* /*request*/, ::fs::SetEavesdropStateResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BlindTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BlindTransfer() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::BlindTransferRequest, ::fs::BlindTransferResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::BlindTransferRequest* request, ::fs::BlindTransferResponse* response) { return this->BlindTransfer(context, request, response); }));}
    void SetMessageAllocatorFor_BlindTransfer(
        ::grpc::MessageAllocator< ::fs::BlindTransferRequest, ::fs::BlindTransferResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::BlindTransferRequest, ::fs::BlindTransferResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BlindTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlindTransfer(::grpc::ServerContext* /*context*/, const ::fs::BlindTransferRequest* /*request*/, ::fs::BlindTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BlindTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::BlindTransferRequest* /*request*/, ::fs::BlindTransferResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_BreakPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_BreakPark() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::fs::BreakParkRequest, ::fs::BreakParkResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::fs::BreakParkRequest* request, ::fs::BreakParkResponse* response) { return this->BreakPark(context, request, response); }));}
    void SetMessageAllocatorFor_BreakPark(
        ::grpc::MessageAllocator< ::fs::BreakParkRequest, ::fs::BreakParkResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::fs::BreakParkRequest, ::fs::BreakParkResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_BreakPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BreakPark(::grpc::ServerContext* /*context*/, const ::fs::BreakParkRequest* /*request*/, ::fs::BreakParkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BreakPark(
      ::grpc::CallbackServerContext* /*context*/, const ::fs::BreakParkRequest* /*request*/, ::fs::BreakParkResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_Originate<WithCallbackMethod_Execute<WithCallbackMethod_SetVariables<WithCallbackMethod_Bridge<WithCallbackMethod_BridgeCall<WithCallbackMethod_StopPlayback<WithCallbackMethod_Hangup<WithCallbackMethod_HangupMatchingVars<WithCallbackMethod_Queue<WithCallbackMethod_HangupMany<WithCallbackMethod_Hold<WithCallbackMethod_UnHold<WithCallbackMethod_SetProfileVar<WithCallbackMethod_ConfirmPush<WithCallbackMethod_Broadcast<WithCallbackMethod_SetEavesdropState<WithCallbackMethod_BlindTransfer<WithCallbackMethod_BreakPark<Service > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Originate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Originate() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Originate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Originate(::grpc::ServerContext* /*context*/, const ::fs::OriginateRequest* /*request*/, ::fs::OriginateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Execute() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::fs::ExecuteRequest* /*request*/, ::fs::ExecuteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetVariables() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::fs::SetVariablesRequest* /*request*/, ::fs::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Bridge() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bridge(::grpc::ServerContext* /*context*/, const ::fs::BridgeRequest* /*request*/, ::fs::BridgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BridgeCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BridgeCall() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_BridgeCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BridgeCall(::grpc::ServerContext* /*context*/, const ::fs::BridgeCallRequest* /*request*/, ::fs::BridgeCallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StopPlayback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StopPlayback() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_StopPlayback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPlayback(::grpc::ServerContext* /*context*/, const ::fs::StopPlaybackRequest* /*request*/, ::fs::StopPlaybackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Hangup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Hangup() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_Hangup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hangup(::grpc::ServerContext* /*context*/, const ::fs::HangupRequest* /*request*/, ::fs::HangupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HangupMatchingVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HangupMatchingVars() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_HangupMatchingVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMatchingVars(::grpc::ServerContext* /*context*/, const ::fs::HangupMatchingVarsReqeust* /*request*/, ::fs::HangupMatchingVarsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Queue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Queue() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_Queue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Queue(::grpc::ServerContext* /*context*/, const ::fs::QueueRequest* /*request*/, ::fs::QueueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HangupMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HangupMany() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_HangupMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMany(::grpc::ServerContext* /*context*/, const ::fs::HangupManyRequest* /*request*/, ::fs::HangupManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Hold() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::fs::HoldRequest* /*request*/, ::fs::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnHold() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_UnHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnHold(::grpc::ServerContext* /*context*/, const ::fs::UnHoldRequest* /*request*/, ::fs::UnHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetProfileVar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetProfileVar() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_SetProfileVar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVar(::grpc::ServerContext* /*context*/, const ::fs::SetProfileVarRequest* /*request*/, ::fs::SetProfileVarResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ConfirmPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ConfirmPush() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ConfirmPush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfirmPush(::grpc::ServerContext* /*context*/, const ::fs::ConfirmPushRequest* /*request*/, ::fs::ConfirmPushResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Broadcast : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Broadcast() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_Broadcast() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Broadcast(::grpc::ServerContext* /*context*/, const ::fs::BroadcastRequest* /*request*/, ::fs::BroadcastResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SetEavesdropState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SetEavesdropState() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_SetEavesdropState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEavesdropState(::grpc::ServerContext* /*context*/, const ::fs::SetEavesdropStateRequest* /*request*/, ::fs::SetEavesdropStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BlindTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BlindTransfer() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_BlindTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlindTransfer(::grpc::ServerContext* /*context*/, const ::fs::BlindTransferRequest* /*request*/, ::fs::BlindTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BreakPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_BreakPark() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_BreakPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BreakPark(::grpc::ServerContext* /*context*/, const ::fs::BreakParkRequest* /*request*/, ::fs::BreakParkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Originate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Originate() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Originate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Originate(::grpc::ServerContext* /*context*/, const ::fs::OriginateRequest* /*request*/, ::fs::OriginateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOriginate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Execute() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::fs::ExecuteRequest* /*request*/, ::fs::ExecuteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetVariables() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::fs::SetVariablesRequest* /*request*/, ::fs::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetVariables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Bridge() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bridge(::grpc::ServerContext* /*context*/, const ::fs::BridgeRequest* /*request*/, ::fs::BridgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBridge(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BridgeCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BridgeCall() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_BridgeCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BridgeCall(::grpc::ServerContext* /*context*/, const ::fs::BridgeCallRequest* /*request*/, ::fs::BridgeCallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBridgeCall(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StopPlayback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StopPlayback() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_StopPlayback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPlayback(::grpc::ServerContext* /*context*/, const ::fs::StopPlaybackRequest* /*request*/, ::fs::StopPlaybackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStopPlayback(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Hangup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Hangup() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_Hangup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hangup(::grpc::ServerContext* /*context*/, const ::fs::HangupRequest* /*request*/, ::fs::HangupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHangup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HangupMatchingVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HangupMatchingVars() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_HangupMatchingVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMatchingVars(::grpc::ServerContext* /*context*/, const ::fs::HangupMatchingVarsReqeust* /*request*/, ::fs::HangupMatchingVarsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHangupMatchingVars(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Queue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Queue() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_Queue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Queue(::grpc::ServerContext* /*context*/, const ::fs::QueueRequest* /*request*/, ::fs::QueueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQueue(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HangupMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HangupMany() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_HangupMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMany(::grpc::ServerContext* /*context*/, const ::fs::HangupManyRequest* /*request*/, ::fs::HangupManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHangupMany(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Hold() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::fs::HoldRequest* /*request*/, ::fs::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHold(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnHold() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_UnHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnHold(::grpc::ServerContext* /*context*/, const ::fs::UnHoldRequest* /*request*/, ::fs::UnHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnHold(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetProfileVar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetProfileVar() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_SetProfileVar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVar(::grpc::ServerContext* /*context*/, const ::fs::SetProfileVarRequest* /*request*/, ::fs::SetProfileVarResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetProfileVar(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ConfirmPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ConfirmPush() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ConfirmPush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfirmPush(::grpc::ServerContext* /*context*/, const ::fs::ConfirmPushRequest* /*request*/, ::fs::ConfirmPushResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestConfirmPush(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Broadcast : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Broadcast() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_Broadcast() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Broadcast(::grpc::ServerContext* /*context*/, const ::fs::BroadcastRequest* /*request*/, ::fs::BroadcastResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBroadcast(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SetEavesdropState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SetEavesdropState() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_SetEavesdropState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEavesdropState(::grpc::ServerContext* /*context*/, const ::fs::SetEavesdropStateRequest* /*request*/, ::fs::SetEavesdropStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSetEavesdropState(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BlindTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BlindTransfer() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_BlindTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlindTransfer(::grpc::ServerContext* /*context*/, const ::fs::BlindTransferRequest* /*request*/, ::fs::BlindTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBlindTransfer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_BreakPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_BreakPark() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_BreakPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BreakPark(::grpc::ServerContext* /*context*/, const ::fs::BreakParkRequest* /*request*/, ::fs::BreakParkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBreakPark(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Originate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Originate() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Originate(context, request, response); }));
    }
    ~WithRawCallbackMethod_Originate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Originate(::grpc::ServerContext* /*context*/, const ::fs::OriginateRequest* /*request*/, ::fs::OriginateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Originate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Execute() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Execute(context, request, response); }));
    }
    ~WithRawCallbackMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::fs::ExecuteRequest* /*request*/, ::fs::ExecuteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Execute(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetVariables() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetVariables(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::fs::SetVariablesRequest* /*request*/, ::fs::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetVariables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Bridge() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Bridge(context, request, response); }));
    }
    ~WithRawCallbackMethod_Bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bridge(::grpc::ServerContext* /*context*/, const ::fs::BridgeRequest* /*request*/, ::fs::BridgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Bridge(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BridgeCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BridgeCall() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BridgeCall(context, request, response); }));
    }
    ~WithRawCallbackMethod_BridgeCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BridgeCall(::grpc::ServerContext* /*context*/, const ::fs::BridgeCallRequest* /*request*/, ::fs::BridgeCallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BridgeCall(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_StopPlayback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_StopPlayback() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->StopPlayback(context, request, response); }));
    }
    ~WithRawCallbackMethod_StopPlayback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StopPlayback(::grpc::ServerContext* /*context*/, const ::fs::StopPlaybackRequest* /*request*/, ::fs::StopPlaybackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* StopPlayback(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Hangup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Hangup() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Hangup(context, request, response); }));
    }
    ~WithRawCallbackMethod_Hangup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hangup(::grpc::ServerContext* /*context*/, const ::fs::HangupRequest* /*request*/, ::fs::HangupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Hangup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HangupMatchingVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HangupMatchingVars() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HangupMatchingVars(context, request, response); }));
    }
    ~WithRawCallbackMethod_HangupMatchingVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMatchingVars(::grpc::ServerContext* /*context*/, const ::fs::HangupMatchingVarsReqeust* /*request*/, ::fs::HangupMatchingVarsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HangupMatchingVars(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Queue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Queue() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Queue(context, request, response); }));
    }
    ~WithRawCallbackMethod_Queue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Queue(::grpc::ServerContext* /*context*/, const ::fs::QueueRequest* /*request*/, ::fs::QueueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Queue(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_HangupMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_HangupMany() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HangupMany(context, request, response); }));
    }
    ~WithRawCallbackMethod_HangupMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HangupMany(::grpc::ServerContext* /*context*/, const ::fs::HangupManyRequest* /*request*/, ::fs::HangupManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* HangupMany(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Hold() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Hold(context, request, response); }));
    }
    ~WithRawCallbackMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::fs::HoldRequest* /*request*/, ::fs::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Hold(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UnHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UnHold() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnHold(context, request, response); }));
    }
    ~WithRawCallbackMethod_UnHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnHold(::grpc::ServerContext* /*context*/, const ::fs::UnHoldRequest* /*request*/, ::fs::UnHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UnHold(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetProfileVar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetProfileVar() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetProfileVar(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetProfileVar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetProfileVar(::grpc::ServerContext* /*context*/, const ::fs::SetProfileVarRequest* /*request*/, ::fs::SetProfileVarResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetProfileVar(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ConfirmPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ConfirmPush() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ConfirmPush(context, request, response); }));
    }
    ~WithRawCallbackMethod_ConfirmPush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ConfirmPush(::grpc::ServerContext* /*context*/, const ::fs::ConfirmPushRequest* /*request*/, ::fs::ConfirmPushResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ConfirmPush(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Broadcast : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Broadcast() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Broadcast(context, request, response); }));
    }
    ~WithRawCallbackMethod_Broadcast() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Broadcast(::grpc::ServerContext* /*context*/, const ::fs::BroadcastRequest* /*request*/, ::fs::BroadcastResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Broadcast(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SetEavesdropState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SetEavesdropState() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SetEavesdropState(context, request, response); }));
    }
    ~WithRawCallbackMethod_SetEavesdropState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SetEavesdropState(::grpc::ServerContext* /*context*/, const ::fs::SetEavesdropStateRequest* /*request*/, ::fs::SetEavesdropStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* SetEavesdropState(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BlindTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BlindTransfer() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BlindTransfer(context, request, response); }));
    }
    ~WithRawCallbackMethod_BlindTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BlindTransfer(::grpc::ServerContext* /*context*/, const ::fs::BlindTransferRequest* /*request*/, ::fs::BlindTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BlindTransfer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_BreakPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_BreakPark() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->BreakPark(context, request, response); }));
    }
    ~WithRawCallbackMethod_BreakPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BreakPark(::grpc::ServerContext* /*context*/, const ::fs::BreakParkRequest* /*request*/, ::fs::BreakParkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* BreakPark(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Originate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Originate() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::OriginateRequest, ::fs::OriginateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::OriginateRequest, ::fs::OriginateResponse>* streamer) {
                       return this->StreamedOriginate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Originate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Originate(::grpc::ServerContext* /*context*/, const ::fs::OriginateRequest* /*request*/, ::fs::OriginateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOriginate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::OriginateRequest,::fs::OriginateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Execute() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::ExecuteRequest, ::fs::ExecuteResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::ExecuteRequest, ::fs::ExecuteResponse>* streamer) {
                       return this->StreamedExecute(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Execute(::grpc::ServerContext* /*context*/, const ::fs::ExecuteRequest* /*request*/, ::fs::ExecuteResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::ExecuteRequest,::fs::ExecuteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetVariables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetVariables() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::SetVariablesRequest, ::fs::SetVariablesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::SetVariablesRequest, ::fs::SetVariablesResponse>* streamer) {
                       return this->StreamedSetVariables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetVariables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetVariables(::grpc::ServerContext* /*context*/, const ::fs::SetVariablesRequest* /*request*/, ::fs::SetVariablesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetVariables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::SetVariablesRequest,::fs::SetVariablesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Bridge : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Bridge() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::BridgeRequest, ::fs::BridgeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::BridgeRequest, ::fs::BridgeResponse>* streamer) {
                       return this->StreamedBridge(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Bridge() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Bridge(::grpc::ServerContext* /*context*/, const ::fs::BridgeRequest* /*request*/, ::fs::BridgeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBridge(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::BridgeRequest,::fs::BridgeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BridgeCall : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BridgeCall() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::BridgeCallRequest, ::fs::BridgeCallResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::BridgeCallRequest, ::fs::BridgeCallResponse>* streamer) {
                       return this->StreamedBridgeCall(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BridgeCall() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BridgeCall(::grpc::ServerContext* /*context*/, const ::fs::BridgeCallRequest* /*request*/, ::fs::BridgeCallResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBridgeCall(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::BridgeCallRequest,::fs::BridgeCallResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StopPlayback : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StopPlayback() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::StopPlaybackRequest, ::fs::StopPlaybackResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::StopPlaybackRequest, ::fs::StopPlaybackResponse>* streamer) {
                       return this->StreamedStopPlayback(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_StopPlayback() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StopPlayback(::grpc::ServerContext* /*context*/, const ::fs::StopPlaybackRequest* /*request*/, ::fs::StopPlaybackResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStopPlayback(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::StopPlaybackRequest,::fs::StopPlaybackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Hangup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Hangup() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::HangupRequest, ::fs::HangupResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::HangupRequest, ::fs::HangupResponse>* streamer) {
                       return this->StreamedHangup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Hangup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Hangup(::grpc::ServerContext* /*context*/, const ::fs::HangupRequest* /*request*/, ::fs::HangupResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHangup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::HangupRequest,::fs::HangupResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HangupMatchingVars : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HangupMatchingVars() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::HangupMatchingVarsReqeust, ::fs::HangupMatchingVarsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::HangupMatchingVarsReqeust, ::fs::HangupMatchingVarsResponse>* streamer) {
                       return this->StreamedHangupMatchingVars(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HangupMatchingVars() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HangupMatchingVars(::grpc::ServerContext* /*context*/, const ::fs::HangupMatchingVarsReqeust* /*request*/, ::fs::HangupMatchingVarsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHangupMatchingVars(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::HangupMatchingVarsReqeust,::fs::HangupMatchingVarsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Queue : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Queue() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::QueueRequest, ::fs::QueueResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::QueueRequest, ::fs::QueueResponse>* streamer) {
                       return this->StreamedQueue(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Queue() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Queue(::grpc::ServerContext* /*context*/, const ::fs::QueueRequest* /*request*/, ::fs::QueueResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQueue(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::QueueRequest,::fs::QueueResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HangupMany : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HangupMany() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::HangupManyRequest, ::fs::HangupManyResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::HangupManyRequest, ::fs::HangupManyResponse>* streamer) {
                       return this->StreamedHangupMany(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HangupMany() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HangupMany(::grpc::ServerContext* /*context*/, const ::fs::HangupManyRequest* /*request*/, ::fs::HangupManyResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHangupMany(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::HangupManyRequest,::fs::HangupManyResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Hold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Hold() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::HoldRequest, ::fs::HoldResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::HoldRequest, ::fs::HoldResponse>* streamer) {
                       return this->StreamedHold(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Hold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Hold(::grpc::ServerContext* /*context*/, const ::fs::HoldRequest* /*request*/, ::fs::HoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHold(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::HoldRequest,::fs::HoldResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnHold : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnHold() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::UnHoldRequest, ::fs::UnHoldResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::UnHoldRequest, ::fs::UnHoldResponse>* streamer) {
                       return this->StreamedUnHold(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnHold() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnHold(::grpc::ServerContext* /*context*/, const ::fs::UnHoldRequest* /*request*/, ::fs::UnHoldResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnHold(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::UnHoldRequest,::fs::UnHoldResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetProfileVar : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetProfileVar() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::SetProfileVarRequest, ::fs::SetProfileVarResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::SetProfileVarRequest, ::fs::SetProfileVarResponse>* streamer) {
                       return this->StreamedSetProfileVar(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetProfileVar() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetProfileVar(::grpc::ServerContext* /*context*/, const ::fs::SetProfileVarRequest* /*request*/, ::fs::SetProfileVarResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetProfileVar(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::SetProfileVarRequest,::fs::SetProfileVarResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ConfirmPush : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ConfirmPush() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::ConfirmPushRequest, ::fs::ConfirmPushResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::ConfirmPushRequest, ::fs::ConfirmPushResponse>* streamer) {
                       return this->StreamedConfirmPush(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ConfirmPush() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ConfirmPush(::grpc::ServerContext* /*context*/, const ::fs::ConfirmPushRequest* /*request*/, ::fs::ConfirmPushResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedConfirmPush(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::ConfirmPushRequest,::fs::ConfirmPushResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Broadcast : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Broadcast() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::BroadcastRequest, ::fs::BroadcastResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::BroadcastRequest, ::fs::BroadcastResponse>* streamer) {
                       return this->StreamedBroadcast(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Broadcast() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Broadcast(::grpc::ServerContext* /*context*/, const ::fs::BroadcastRequest* /*request*/, ::fs::BroadcastResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBroadcast(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::BroadcastRequest,::fs::BroadcastResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SetEavesdropState : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SetEavesdropState() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::SetEavesdropStateRequest, ::fs::SetEavesdropStateResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::SetEavesdropStateRequest, ::fs::SetEavesdropStateResponse>* streamer) {
                       return this->StreamedSetEavesdropState(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SetEavesdropState() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SetEavesdropState(::grpc::ServerContext* /*context*/, const ::fs::SetEavesdropStateRequest* /*request*/, ::fs::SetEavesdropStateResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSetEavesdropState(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::SetEavesdropStateRequest,::fs::SetEavesdropStateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BlindTransfer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BlindTransfer() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::BlindTransferRequest, ::fs::BlindTransferResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::BlindTransferRequest, ::fs::BlindTransferResponse>* streamer) {
                       return this->StreamedBlindTransfer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BlindTransfer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BlindTransfer(::grpc::ServerContext* /*context*/, const ::fs::BlindTransferRequest* /*request*/, ::fs::BlindTransferResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBlindTransfer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::BlindTransferRequest,::fs::BlindTransferResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BreakPark : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_BreakPark() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::fs::BreakParkRequest, ::fs::BreakParkResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::fs::BreakParkRequest, ::fs::BreakParkResponse>* streamer) {
                       return this->StreamedBreakPark(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_BreakPark() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BreakPark(::grpc::ServerContext* /*context*/, const ::fs::BreakParkRequest* /*request*/, ::fs::BreakParkResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBreakPark(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::fs::BreakParkRequest,::fs::BreakParkResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Originate<WithStreamedUnaryMethod_Execute<WithStreamedUnaryMethod_SetVariables<WithStreamedUnaryMethod_Bridge<WithStreamedUnaryMethod_BridgeCall<WithStreamedUnaryMethod_StopPlayback<WithStreamedUnaryMethod_Hangup<WithStreamedUnaryMethod_HangupMatchingVars<WithStreamedUnaryMethod_Queue<WithStreamedUnaryMethod_HangupMany<WithStreamedUnaryMethod_Hold<WithStreamedUnaryMethod_UnHold<WithStreamedUnaryMethod_SetProfileVar<WithStreamedUnaryMethod_ConfirmPush<WithStreamedUnaryMethod_Broadcast<WithStreamedUnaryMethod_SetEavesdropState<WithStreamedUnaryMethod_BlindTransfer<WithStreamedUnaryMethod_BreakPark<Service > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Originate<WithStreamedUnaryMethod_Execute<WithStreamedUnaryMethod_SetVariables<WithStreamedUnaryMethod_Bridge<WithStreamedUnaryMethod_BridgeCall<WithStreamedUnaryMethod_StopPlayback<WithStreamedUnaryMethod_Hangup<WithStreamedUnaryMethod_HangupMatchingVars<WithStreamedUnaryMethod_Queue<WithStreamedUnaryMethod_HangupMany<WithStreamedUnaryMethod_Hold<WithStreamedUnaryMethod_UnHold<WithStreamedUnaryMethod_SetProfileVar<WithStreamedUnaryMethod_ConfirmPush<WithStreamedUnaryMethod_Broadcast<WithStreamedUnaryMethod_SetEavesdropState<WithStreamedUnaryMethod_BlindTransfer<WithStreamedUnaryMethod_BreakPark<Service > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace fs


#endif  // GRPC_fs_2eproto__INCLUDED
