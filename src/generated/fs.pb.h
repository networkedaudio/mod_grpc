// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_fs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_fs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_fs_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_fs_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_fs_2eproto;
namespace fs {
class BlindTransferRequest;
struct BlindTransferRequestDefaultTypeInternal;
extern BlindTransferRequestDefaultTypeInternal _BlindTransferRequest_default_instance_;
class BlindTransferRequest_VariablesEntry_DoNotUse;
struct BlindTransferRequest_VariablesEntry_DoNotUseDefaultTypeInternal;
extern BlindTransferRequest_VariablesEntry_DoNotUseDefaultTypeInternal _BlindTransferRequest_VariablesEntry_DoNotUse_default_instance_;
class BlindTransferResponse;
struct BlindTransferResponseDefaultTypeInternal;
extern BlindTransferResponseDefaultTypeInternal _BlindTransferResponse_default_instance_;
class BreakParkRequest;
struct BreakParkRequestDefaultTypeInternal;
extern BreakParkRequestDefaultTypeInternal _BreakParkRequest_default_instance_;
class BreakParkRequest_VariablesEntry_DoNotUse;
struct BreakParkRequest_VariablesEntry_DoNotUseDefaultTypeInternal;
extern BreakParkRequest_VariablesEntry_DoNotUseDefaultTypeInternal _BreakParkRequest_VariablesEntry_DoNotUse_default_instance_;
class BreakParkResponse;
struct BreakParkResponseDefaultTypeInternal;
extern BreakParkResponseDefaultTypeInternal _BreakParkResponse_default_instance_;
class BridgeCallRequest;
struct BridgeCallRequestDefaultTypeInternal;
extern BridgeCallRequestDefaultTypeInternal _BridgeCallRequest_default_instance_;
class BridgeCallRequest_VariablesEntry_DoNotUse;
struct BridgeCallRequest_VariablesEntry_DoNotUseDefaultTypeInternal;
extern BridgeCallRequest_VariablesEntry_DoNotUseDefaultTypeInternal _BridgeCallRequest_VariablesEntry_DoNotUse_default_instance_;
class BridgeCallResponse;
struct BridgeCallResponseDefaultTypeInternal;
extern BridgeCallResponseDefaultTypeInternal _BridgeCallResponse_default_instance_;
class BridgeRequest;
struct BridgeRequestDefaultTypeInternal;
extern BridgeRequestDefaultTypeInternal _BridgeRequest_default_instance_;
class BridgeResponse;
struct BridgeResponseDefaultTypeInternal;
extern BridgeResponseDefaultTypeInternal _BridgeResponse_default_instance_;
class BroadcastRequest;
struct BroadcastRequestDefaultTypeInternal;
extern BroadcastRequestDefaultTypeInternal _BroadcastRequest_default_instance_;
class BroadcastResponse;
struct BroadcastResponseDefaultTypeInternal;
extern BroadcastResponseDefaultTypeInternal _BroadcastResponse_default_instance_;
class ConfirmPushRequest;
struct ConfirmPushRequestDefaultTypeInternal;
extern ConfirmPushRequestDefaultTypeInternal _ConfirmPushRequest_default_instance_;
class ConfirmPushResponse;
struct ConfirmPushResponseDefaultTypeInternal;
extern ConfirmPushResponseDefaultTypeInternal _ConfirmPushResponse_default_instance_;
class ErrorExecute;
struct ErrorExecuteDefaultTypeInternal;
extern ErrorExecuteDefaultTypeInternal _ErrorExecute_default_instance_;
class ExecuteRequest;
struct ExecuteRequestDefaultTypeInternal;
extern ExecuteRequestDefaultTypeInternal _ExecuteRequest_default_instance_;
class ExecuteResponse;
struct ExecuteResponseDefaultTypeInternal;
extern ExecuteResponseDefaultTypeInternal _ExecuteResponse_default_instance_;
class HangupManyRequest;
struct HangupManyRequestDefaultTypeInternal;
extern HangupManyRequestDefaultTypeInternal _HangupManyRequest_default_instance_;
class HangupManyResponse;
struct HangupManyResponseDefaultTypeInternal;
extern HangupManyResponseDefaultTypeInternal _HangupManyResponse_default_instance_;
class HangupMatchingVarsReqeust;
struct HangupMatchingVarsReqeustDefaultTypeInternal;
extern HangupMatchingVarsReqeustDefaultTypeInternal _HangupMatchingVarsReqeust_default_instance_;
class HangupMatchingVarsReqeust_VariablesEntry_DoNotUse;
struct HangupMatchingVarsReqeust_VariablesEntry_DoNotUseDefaultTypeInternal;
extern HangupMatchingVarsReqeust_VariablesEntry_DoNotUseDefaultTypeInternal _HangupMatchingVarsReqeust_VariablesEntry_DoNotUse_default_instance_;
class HangupMatchingVarsResponse;
struct HangupMatchingVarsResponseDefaultTypeInternal;
extern HangupMatchingVarsResponseDefaultTypeInternal _HangupMatchingVarsResponse_default_instance_;
class HangupRequest;
struct HangupRequestDefaultTypeInternal;
extern HangupRequestDefaultTypeInternal _HangupRequest_default_instance_;
class HangupRequest_VariablesEntry_DoNotUse;
struct HangupRequest_VariablesEntry_DoNotUseDefaultTypeInternal;
extern HangupRequest_VariablesEntry_DoNotUseDefaultTypeInternal _HangupRequest_VariablesEntry_DoNotUse_default_instance_;
class HangupResponse;
struct HangupResponseDefaultTypeInternal;
extern HangupResponseDefaultTypeInternal _HangupResponse_default_instance_;
class HoldRequest;
struct HoldRequestDefaultTypeInternal;
extern HoldRequestDefaultTypeInternal _HoldRequest_default_instance_;
class HoldResponse;
struct HoldResponseDefaultTypeInternal;
extern HoldResponseDefaultTypeInternal _HoldResponse_default_instance_;
class OriginateRequest;
struct OriginateRequestDefaultTypeInternal;
extern OriginateRequestDefaultTypeInternal _OriginateRequest_default_instance_;
class OriginateRequest_Extension;
struct OriginateRequest_ExtensionDefaultTypeInternal;
extern OriginateRequest_ExtensionDefaultTypeInternal _OriginateRequest_Extension_default_instance_;
class OriginateRequest_VariablesEntry_DoNotUse;
struct OriginateRequest_VariablesEntry_DoNotUseDefaultTypeInternal;
extern OriginateRequest_VariablesEntry_DoNotUseDefaultTypeInternal _OriginateRequest_VariablesEntry_DoNotUse_default_instance_;
class OriginateResponse;
struct OriginateResponseDefaultTypeInternal;
extern OriginateResponseDefaultTypeInternal _OriginateResponse_default_instance_;
class QueueRequest;
struct QueueRequestDefaultTypeInternal;
extern QueueRequestDefaultTypeInternal _QueueRequest_default_instance_;
class QueueRequest_VariablesEntry_DoNotUse;
struct QueueRequest_VariablesEntry_DoNotUseDefaultTypeInternal;
extern QueueRequest_VariablesEntry_DoNotUseDefaultTypeInternal _QueueRequest_VariablesEntry_DoNotUse_default_instance_;
class QueueResponse;
struct QueueResponseDefaultTypeInternal;
extern QueueResponseDefaultTypeInternal _QueueResponse_default_instance_;
class SetEavesdropStateRequest;
struct SetEavesdropStateRequestDefaultTypeInternal;
extern SetEavesdropStateRequestDefaultTypeInternal _SetEavesdropStateRequest_default_instance_;
class SetEavesdropStateResponse;
struct SetEavesdropStateResponseDefaultTypeInternal;
extern SetEavesdropStateResponseDefaultTypeInternal _SetEavesdropStateResponse_default_instance_;
class SetProfileVarRequest;
struct SetProfileVarRequestDefaultTypeInternal;
extern SetProfileVarRequestDefaultTypeInternal _SetProfileVarRequest_default_instance_;
class SetProfileVarRequest_VariablesEntry_DoNotUse;
struct SetProfileVarRequest_VariablesEntry_DoNotUseDefaultTypeInternal;
extern SetProfileVarRequest_VariablesEntry_DoNotUseDefaultTypeInternal _SetProfileVarRequest_VariablesEntry_DoNotUse_default_instance_;
class SetProfileVarResponse;
struct SetProfileVarResponseDefaultTypeInternal;
extern SetProfileVarResponseDefaultTypeInternal _SetProfileVarResponse_default_instance_;
class SetVariablesRequest;
struct SetVariablesRequestDefaultTypeInternal;
extern SetVariablesRequestDefaultTypeInternal _SetVariablesRequest_default_instance_;
class SetVariablesRequest_VariablesEntry_DoNotUse;
struct SetVariablesRequest_VariablesEntry_DoNotUseDefaultTypeInternal;
extern SetVariablesRequest_VariablesEntry_DoNotUseDefaultTypeInternal _SetVariablesRequest_VariablesEntry_DoNotUse_default_instance_;
class SetVariablesResponse;
struct SetVariablesResponseDefaultTypeInternal;
extern SetVariablesResponseDefaultTypeInternal _SetVariablesResponse_default_instance_;
class StopPlaybackRequest;
struct StopPlaybackRequestDefaultTypeInternal;
extern StopPlaybackRequestDefaultTypeInternal _StopPlaybackRequest_default_instance_;
class StopPlaybackResponse;
struct StopPlaybackResponseDefaultTypeInternal;
extern StopPlaybackResponseDefaultTypeInternal _StopPlaybackResponse_default_instance_;
class UnHoldRequest;
struct UnHoldRequestDefaultTypeInternal;
extern UnHoldRequestDefaultTypeInternal _UnHoldRequest_default_instance_;
class UnHoldResponse;
struct UnHoldResponseDefaultTypeInternal;
extern UnHoldResponseDefaultTypeInternal _UnHoldResponse_default_instance_;
}  // namespace fs
PROTOBUF_NAMESPACE_OPEN
template<> ::fs::BlindTransferRequest* Arena::CreateMaybeMessage<::fs::BlindTransferRequest>(Arena*);
template<> ::fs::BlindTransferRequest_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::BlindTransferRequest_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::BlindTransferResponse* Arena::CreateMaybeMessage<::fs::BlindTransferResponse>(Arena*);
template<> ::fs::BreakParkRequest* Arena::CreateMaybeMessage<::fs::BreakParkRequest>(Arena*);
template<> ::fs::BreakParkRequest_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::BreakParkRequest_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::BreakParkResponse* Arena::CreateMaybeMessage<::fs::BreakParkResponse>(Arena*);
template<> ::fs::BridgeCallRequest* Arena::CreateMaybeMessage<::fs::BridgeCallRequest>(Arena*);
template<> ::fs::BridgeCallRequest_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::BridgeCallRequest_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::BridgeCallResponse* Arena::CreateMaybeMessage<::fs::BridgeCallResponse>(Arena*);
template<> ::fs::BridgeRequest* Arena::CreateMaybeMessage<::fs::BridgeRequest>(Arena*);
template<> ::fs::BridgeResponse* Arena::CreateMaybeMessage<::fs::BridgeResponse>(Arena*);
template<> ::fs::BroadcastRequest* Arena::CreateMaybeMessage<::fs::BroadcastRequest>(Arena*);
template<> ::fs::BroadcastResponse* Arena::CreateMaybeMessage<::fs::BroadcastResponse>(Arena*);
template<> ::fs::ConfirmPushRequest* Arena::CreateMaybeMessage<::fs::ConfirmPushRequest>(Arena*);
template<> ::fs::ConfirmPushResponse* Arena::CreateMaybeMessage<::fs::ConfirmPushResponse>(Arena*);
template<> ::fs::ErrorExecute* Arena::CreateMaybeMessage<::fs::ErrorExecute>(Arena*);
template<> ::fs::ExecuteRequest* Arena::CreateMaybeMessage<::fs::ExecuteRequest>(Arena*);
template<> ::fs::ExecuteResponse* Arena::CreateMaybeMessage<::fs::ExecuteResponse>(Arena*);
template<> ::fs::HangupManyRequest* Arena::CreateMaybeMessage<::fs::HangupManyRequest>(Arena*);
template<> ::fs::HangupManyResponse* Arena::CreateMaybeMessage<::fs::HangupManyResponse>(Arena*);
template<> ::fs::HangupMatchingVarsReqeust* Arena::CreateMaybeMessage<::fs::HangupMatchingVarsReqeust>(Arena*);
template<> ::fs::HangupMatchingVarsReqeust_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::HangupMatchingVarsReqeust_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::HangupMatchingVarsResponse* Arena::CreateMaybeMessage<::fs::HangupMatchingVarsResponse>(Arena*);
template<> ::fs::HangupRequest* Arena::CreateMaybeMessage<::fs::HangupRequest>(Arena*);
template<> ::fs::HangupRequest_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::HangupRequest_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::HangupResponse* Arena::CreateMaybeMessage<::fs::HangupResponse>(Arena*);
template<> ::fs::HoldRequest* Arena::CreateMaybeMessage<::fs::HoldRequest>(Arena*);
template<> ::fs::HoldResponse* Arena::CreateMaybeMessage<::fs::HoldResponse>(Arena*);
template<> ::fs::OriginateRequest* Arena::CreateMaybeMessage<::fs::OriginateRequest>(Arena*);
template<> ::fs::OriginateRequest_Extension* Arena::CreateMaybeMessage<::fs::OriginateRequest_Extension>(Arena*);
template<> ::fs::OriginateRequest_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::OriginateRequest_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::OriginateResponse* Arena::CreateMaybeMessage<::fs::OriginateResponse>(Arena*);
template<> ::fs::QueueRequest* Arena::CreateMaybeMessage<::fs::QueueRequest>(Arena*);
template<> ::fs::QueueRequest_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::QueueRequest_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::QueueResponse* Arena::CreateMaybeMessage<::fs::QueueResponse>(Arena*);
template<> ::fs::SetEavesdropStateRequest* Arena::CreateMaybeMessage<::fs::SetEavesdropStateRequest>(Arena*);
template<> ::fs::SetEavesdropStateResponse* Arena::CreateMaybeMessage<::fs::SetEavesdropStateResponse>(Arena*);
template<> ::fs::SetProfileVarRequest* Arena::CreateMaybeMessage<::fs::SetProfileVarRequest>(Arena*);
template<> ::fs::SetProfileVarRequest_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::SetProfileVarRequest_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::SetProfileVarResponse* Arena::CreateMaybeMessage<::fs::SetProfileVarResponse>(Arena*);
template<> ::fs::SetVariablesRequest* Arena::CreateMaybeMessage<::fs::SetVariablesRequest>(Arena*);
template<> ::fs::SetVariablesRequest_VariablesEntry_DoNotUse* Arena::CreateMaybeMessage<::fs::SetVariablesRequest_VariablesEntry_DoNotUse>(Arena*);
template<> ::fs::SetVariablesResponse* Arena::CreateMaybeMessage<::fs::SetVariablesResponse>(Arena*);
template<> ::fs::StopPlaybackRequest* Arena::CreateMaybeMessage<::fs::StopPlaybackRequest>(Arena*);
template<> ::fs::StopPlaybackResponse* Arena::CreateMaybeMessage<::fs::StopPlaybackResponse>(Arena*);
template<> ::fs::UnHoldRequest* Arena::CreateMaybeMessage<::fs::UnHoldRequest>(Arena*);
template<> ::fs::UnHoldResponse* Arena::CreateMaybeMessage<::fs::UnHoldResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace fs {

enum ErrorExecute_Type : int {
  ErrorExecute_Type_ERROR = 0,
  ErrorExecute_Type_USAGE = 1,
  ErrorExecute_Type_ErrorExecute_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ErrorExecute_Type_ErrorExecute_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ErrorExecute_Type_IsValid(int value);
constexpr ErrorExecute_Type ErrorExecute_Type_Type_MIN = ErrorExecute_Type_ERROR;
constexpr ErrorExecute_Type ErrorExecute_Type_Type_MAX = ErrorExecute_Type_USAGE;
constexpr int ErrorExecute_Type_Type_ARRAYSIZE = ErrorExecute_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ErrorExecute_Type_descriptor();
template<typename T>
inline const std::string& ErrorExecute_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ErrorExecute_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ErrorExecute_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ErrorExecute_Type_descriptor(), enum_t_value);
}
inline bool ErrorExecute_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ErrorExecute_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ErrorExecute_Type>(
    ErrorExecute_Type_descriptor(), name, value);
}
enum OriginateRequest_Strategy : int {
  OriginateRequest_Strategy_FAILOVER = 0,
  OriginateRequest_Strategy_MULTIPLE = 1,
  OriginateRequest_Strategy_OriginateRequest_Strategy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OriginateRequest_Strategy_OriginateRequest_Strategy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OriginateRequest_Strategy_IsValid(int value);
constexpr OriginateRequest_Strategy OriginateRequest_Strategy_Strategy_MIN = OriginateRequest_Strategy_FAILOVER;
constexpr OriginateRequest_Strategy OriginateRequest_Strategy_Strategy_MAX = OriginateRequest_Strategy_MULTIPLE;
constexpr int OriginateRequest_Strategy_Strategy_ARRAYSIZE = OriginateRequest_Strategy_Strategy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OriginateRequest_Strategy_descriptor();
template<typename T>
inline const std::string& OriginateRequest_Strategy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OriginateRequest_Strategy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OriginateRequest_Strategy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OriginateRequest_Strategy_descriptor(), enum_t_value);
}
inline bool OriginateRequest_Strategy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OriginateRequest_Strategy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OriginateRequest_Strategy>(
    OriginateRequest_Strategy_descriptor(), name, value);
}
// ===================================================================

class BreakParkRequest_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BreakParkRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BreakParkRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  BreakParkRequest_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BreakParkRequest_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BreakParkRequest_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BreakParkRequest_VariablesEntry_DoNotUse& other);
  static const BreakParkRequest_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BreakParkRequest_VariablesEntry_DoNotUse*>(&_BreakParkRequest_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.BreakParkRequest.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.BreakParkRequest.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class BreakParkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BreakParkRequest) */ {
 public:
  inline BreakParkRequest() : BreakParkRequest(nullptr) {}
  ~BreakParkRequest() override;
  explicit PROTOBUF_CONSTEXPR BreakParkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakParkRequest(const BreakParkRequest& from);
  BreakParkRequest(BreakParkRequest&& from) noexcept
    : BreakParkRequest() {
    *this = ::std::move(from);
  }

  inline BreakParkRequest& operator=(const BreakParkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakParkRequest& operator=(BreakParkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakParkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakParkRequest* internal_default_instance() {
    return reinterpret_cast<const BreakParkRequest*>(
               &_BreakParkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(BreakParkRequest& a, BreakParkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakParkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakParkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakParkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakParkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakParkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakParkRequest& from) {
    BreakParkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakParkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BreakParkRequest";
  }
  protected:
  explicit BreakParkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // map<string, string> variables = 2;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.BreakParkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BreakParkRequest_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BreakParkResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BreakParkResponse) */ {
 public:
  inline BreakParkResponse() : BreakParkResponse(nullptr) {}
  ~BreakParkResponse() override;
  explicit PROTOBUF_CONSTEXPR BreakParkResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BreakParkResponse(const BreakParkResponse& from);
  BreakParkResponse(BreakParkResponse&& from) noexcept
    : BreakParkResponse() {
    *this = ::std::move(from);
  }

  inline BreakParkResponse& operator=(const BreakParkResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BreakParkResponse& operator=(BreakParkResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BreakParkResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BreakParkResponse* internal_default_instance() {
    return reinterpret_cast<const BreakParkResponse*>(
               &_BreakParkResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BreakParkResponse& a, BreakParkResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BreakParkResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BreakParkResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BreakParkResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BreakParkResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BreakParkResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BreakParkResponse& from) {
    BreakParkResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BreakParkResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BreakParkResponse";
  }
  protected:
  explicit BreakParkResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOkFieldNumber = 1,
  };
  // bool ok = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fs.BreakParkResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BlindTransferRequest_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BlindTransferRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BlindTransferRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  BlindTransferRequest_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BlindTransferRequest_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BlindTransferRequest_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BlindTransferRequest_VariablesEntry_DoNotUse& other);
  static const BlindTransferRequest_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BlindTransferRequest_VariablesEntry_DoNotUse*>(&_BlindTransferRequest_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.BlindTransferRequest.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.BlindTransferRequest.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class BlindTransferRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BlindTransferRequest) */ {
 public:
  inline BlindTransferRequest() : BlindTransferRequest(nullptr) {}
  ~BlindTransferRequest() override;
  explicit PROTOBUF_CONSTEXPR BlindTransferRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlindTransferRequest(const BlindTransferRequest& from);
  BlindTransferRequest(BlindTransferRequest&& from) noexcept
    : BlindTransferRequest() {
    *this = ::std::move(from);
  }

  inline BlindTransferRequest& operator=(const BlindTransferRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlindTransferRequest& operator=(BlindTransferRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlindTransferRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlindTransferRequest* internal_default_instance() {
    return reinterpret_cast<const BlindTransferRequest*>(
               &_BlindTransferRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(BlindTransferRequest& a, BlindTransferRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BlindTransferRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlindTransferRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlindTransferRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlindTransferRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlindTransferRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlindTransferRequest& from) {
    BlindTransferRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlindTransferRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BlindTransferRequest";
  }
  protected:
  explicit BlindTransferRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 3,
    kIdFieldNumber = 1,
    kDestinationFieldNumber = 2,
    kDialplanFieldNumber = 4,
    kContextFieldNumber = 5,
  };
  // map<string, string> variables = 3;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string destination = 2;
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // string dialplan = 4;
  void clear_dialplan();
  const std::string& dialplan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dialplan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dialplan();
  PROTOBUF_NODISCARD std::string* release_dialplan();
  void set_allocated_dialplan(std::string* dialplan);
  private:
  const std::string& _internal_dialplan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialplan(const std::string& value);
  std::string* _internal_mutable_dialplan();
  public:

  // string context = 5;
  void clear_context();
  const std::string& context() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_context(ArgT0&& arg0, ArgT... args);
  std::string* mutable_context();
  PROTOBUF_NODISCARD std::string* release_context();
  void set_allocated_context(std::string* context);
  private:
  const std::string& _internal_context() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context(const std::string& value);
  std::string* _internal_mutable_context();
  public:

  // @@protoc_insertion_point(class_scope:fs.BlindTransferRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BlindTransferRequest_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dialplan_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr context_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BlindTransferResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BlindTransferResponse) */ {
 public:
  inline BlindTransferResponse() : BlindTransferResponse(nullptr) {}
  ~BlindTransferResponse() override;
  explicit PROTOBUF_CONSTEXPR BlindTransferResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlindTransferResponse(const BlindTransferResponse& from);
  BlindTransferResponse(BlindTransferResponse&& from) noexcept
    : BlindTransferResponse() {
    *this = ::std::move(from);
  }

  inline BlindTransferResponse& operator=(const BlindTransferResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlindTransferResponse& operator=(BlindTransferResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlindTransferResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlindTransferResponse* internal_default_instance() {
    return reinterpret_cast<const BlindTransferResponse*>(
               &_BlindTransferResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlindTransferResponse& a, BlindTransferResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlindTransferResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlindTransferResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlindTransferResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlindTransferResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlindTransferResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlindTransferResponse& from) {
    BlindTransferResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlindTransferResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BlindTransferResponse";
  }
  protected:
  explicit BlindTransferResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // .fs.ErrorExecute error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.BlindTransferResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class SetEavesdropStateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.SetEavesdropStateRequest) */ {
 public:
  inline SetEavesdropStateRequest() : SetEavesdropStateRequest(nullptr) {}
  ~SetEavesdropStateRequest() override;
  explicit PROTOBUF_CONSTEXPR SetEavesdropStateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEavesdropStateRequest(const SetEavesdropStateRequest& from);
  SetEavesdropStateRequest(SetEavesdropStateRequest&& from) noexcept
    : SetEavesdropStateRequest() {
    *this = ::std::move(from);
  }

  inline SetEavesdropStateRequest& operator=(const SetEavesdropStateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEavesdropStateRequest& operator=(SetEavesdropStateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEavesdropStateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEavesdropStateRequest* internal_default_instance() {
    return reinterpret_cast<const SetEavesdropStateRequest*>(
               &_SetEavesdropStateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SetEavesdropStateRequest& a, SetEavesdropStateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEavesdropStateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEavesdropStateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetEavesdropStateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetEavesdropStateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEavesdropStateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetEavesdropStateRequest& from) {
    SetEavesdropStateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEavesdropStateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.SetEavesdropStateRequest";
  }
  protected:
  explicit SetEavesdropStateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string state = 2;
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // @@protoc_insertion_point(class_scope:fs.SetEavesdropStateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class SetEavesdropStateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.SetEavesdropStateResponse) */ {
 public:
  inline SetEavesdropStateResponse() : SetEavesdropStateResponse(nullptr) {}
  ~SetEavesdropStateResponse() override;
  explicit PROTOBUF_CONSTEXPR SetEavesdropStateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetEavesdropStateResponse(const SetEavesdropStateResponse& from);
  SetEavesdropStateResponse(SetEavesdropStateResponse&& from) noexcept
    : SetEavesdropStateResponse() {
    *this = ::std::move(from);
  }

  inline SetEavesdropStateResponse& operator=(const SetEavesdropStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetEavesdropStateResponse& operator=(SetEavesdropStateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetEavesdropStateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetEavesdropStateResponse* internal_default_instance() {
    return reinterpret_cast<const SetEavesdropStateResponse*>(
               &_SetEavesdropStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SetEavesdropStateResponse& a, SetEavesdropStateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetEavesdropStateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetEavesdropStateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetEavesdropStateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetEavesdropStateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetEavesdropStateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetEavesdropStateResponse& from) {
    SetEavesdropStateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetEavesdropStateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.SetEavesdropStateResponse";
  }
  protected:
  explicit SetEavesdropStateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // .fs.ErrorExecute error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.SetEavesdropStateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BroadcastRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BroadcastRequest) */ {
 public:
  inline BroadcastRequest() : BroadcastRequest(nullptr) {}
  ~BroadcastRequest() override;
  explicit PROTOBUF_CONSTEXPR BroadcastRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastRequest(const BroadcastRequest& from);
  BroadcastRequest(BroadcastRequest&& from) noexcept
    : BroadcastRequest() {
    *this = ::std::move(from);
  }

  inline BroadcastRequest& operator=(const BroadcastRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastRequest& operator=(BroadcastRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastRequest* internal_default_instance() {
    return reinterpret_cast<const BroadcastRequest*>(
               &_BroadcastRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BroadcastRequest& a, BroadcastRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BroadcastRequest& from) {
    BroadcastRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BroadcastRequest";
  }
  protected:
  explicit BroadcastRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kArgsFieldNumber = 2,
    kLegFieldNumber = 4,
    kWaitForAnswerFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string args = 2;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // string leg = 4;
  void clear_leg();
  const std::string& leg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leg();
  PROTOBUF_NODISCARD std::string* release_leg();
  void set_allocated_leg(std::string* leg);
  private:
  const std::string& _internal_leg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leg(const std::string& value);
  std::string* _internal_mutable_leg();
  public:

  // bool wait_for_answer = 3;
  void clear_wait_for_answer();
  bool wait_for_answer() const;
  void set_wait_for_answer(bool value);
  private:
  bool _internal_wait_for_answer() const;
  void _internal_set_wait_for_answer(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fs.BroadcastRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leg_;
    bool wait_for_answer_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BroadcastResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BroadcastResponse) */ {
 public:
  inline BroadcastResponse() : BroadcastResponse(nullptr) {}
  ~BroadcastResponse() override;
  explicit PROTOBUF_CONSTEXPR BroadcastResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastResponse(const BroadcastResponse& from);
  BroadcastResponse(BroadcastResponse&& from) noexcept
    : BroadcastResponse() {
    *this = ::std::move(from);
  }

  inline BroadcastResponse& operator=(const BroadcastResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastResponse& operator=(BroadcastResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastResponse* internal_default_instance() {
    return reinterpret_cast<const BroadcastResponse*>(
               &_BroadcastResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BroadcastResponse& a, BroadcastResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BroadcastResponse& from) {
    BroadcastResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BroadcastResponse";
  }
  protected:
  explicit BroadcastResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .fs.ErrorExecute error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.BroadcastResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ConfirmPushRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.ConfirmPushRequest) */ {
 public:
  inline ConfirmPushRequest() : ConfirmPushRequest(nullptr) {}
  ~ConfirmPushRequest() override;
  explicit PROTOBUF_CONSTEXPR ConfirmPushRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmPushRequest(const ConfirmPushRequest& from);
  ConfirmPushRequest(ConfirmPushRequest&& from) noexcept
    : ConfirmPushRequest() {
    *this = ::std::move(from);
  }

  inline ConfirmPushRequest& operator=(const ConfirmPushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmPushRequest& operator=(ConfirmPushRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmPushRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmPushRequest* internal_default_instance() {
    return reinterpret_cast<const ConfirmPushRequest*>(
               &_ConfirmPushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ConfirmPushRequest& a, ConfirmPushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmPushRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmPushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmPushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmPushRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmPushRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmPushRequest& from) {
    ConfirmPushRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmPushRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.ConfirmPushRequest";
  }
  protected:
  explicit ConfirmPushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.ConfirmPushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ConfirmPushResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.ConfirmPushResponse) */ {
 public:
  inline ConfirmPushResponse() : ConfirmPushResponse(nullptr) {}
  ~ConfirmPushResponse() override;
  explicit PROTOBUF_CONSTEXPR ConfirmPushResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmPushResponse(const ConfirmPushResponse& from);
  ConfirmPushResponse(ConfirmPushResponse&& from) noexcept
    : ConfirmPushResponse() {
    *this = ::std::move(from);
  }

  inline ConfirmPushResponse& operator=(const ConfirmPushResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmPushResponse& operator=(ConfirmPushResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmPushResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmPushResponse* internal_default_instance() {
    return reinterpret_cast<const ConfirmPushResponse*>(
               &_ConfirmPushResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ConfirmPushResponse& a, ConfirmPushResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmPushResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmPushResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmPushResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmPushResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmPushResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmPushResponse& from) {
    ConfirmPushResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmPushResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.ConfirmPushResponse";
  }
  protected:
  explicit ConfirmPushResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // .fs.ErrorExecute error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.ConfirmPushResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class SetProfileVarRequest_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetProfileVarRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetProfileVarRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SetProfileVarRequest_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SetProfileVarRequest_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetProfileVarRequest_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetProfileVarRequest_VariablesEntry_DoNotUse& other);
  static const SetProfileVarRequest_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetProfileVarRequest_VariablesEntry_DoNotUse*>(&_SetProfileVarRequest_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.SetProfileVarRequest.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.SetProfileVarRequest.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class SetProfileVarRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.SetProfileVarRequest) */ {
 public:
  inline SetProfileVarRequest() : SetProfileVarRequest(nullptr) {}
  ~SetProfileVarRequest() override;
  explicit PROTOBUF_CONSTEXPR SetProfileVarRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetProfileVarRequest(const SetProfileVarRequest& from);
  SetProfileVarRequest(SetProfileVarRequest&& from) noexcept
    : SetProfileVarRequest() {
    *this = ::std::move(from);
  }

  inline SetProfileVarRequest& operator=(const SetProfileVarRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProfileVarRequest& operator=(SetProfileVarRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetProfileVarRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetProfileVarRequest* internal_default_instance() {
    return reinterpret_cast<const SetProfileVarRequest*>(
               &_SetProfileVarRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SetProfileVarRequest& a, SetProfileVarRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProfileVarRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProfileVarRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetProfileVarRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetProfileVarRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetProfileVarRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetProfileVarRequest& from) {
    SetProfileVarRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetProfileVarRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.SetProfileVarRequest";
  }
  protected:
  explicit SetProfileVarRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // map<string, string> variables = 2;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.SetProfileVarRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetProfileVarRequest_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class SetProfileVarResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:fs.SetProfileVarResponse) */ {
 public:
  inline SetProfileVarResponse() : SetProfileVarResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetProfileVarResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetProfileVarResponse(const SetProfileVarResponse& from);
  SetProfileVarResponse(SetProfileVarResponse&& from) noexcept
    : SetProfileVarResponse() {
    *this = ::std::move(from);
  }

  inline SetProfileVarResponse& operator=(const SetProfileVarResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetProfileVarResponse& operator=(SetProfileVarResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetProfileVarResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetProfileVarResponse* internal_default_instance() {
    return reinterpret_cast<const SetProfileVarResponse*>(
               &_SetProfileVarResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetProfileVarResponse& a, SetProfileVarResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetProfileVarResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetProfileVarResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetProfileVarResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetProfileVarResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetProfileVarResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetProfileVarResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.SetProfileVarResponse";
  }
  protected:
  explicit SetProfileVarResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fs.SetProfileVarResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class StopPlaybackRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.StopPlaybackRequest) */ {
 public:
  inline StopPlaybackRequest() : StopPlaybackRequest(nullptr) {}
  ~StopPlaybackRequest() override;
  explicit PROTOBUF_CONSTEXPR StopPlaybackRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopPlaybackRequest(const StopPlaybackRequest& from);
  StopPlaybackRequest(StopPlaybackRequest&& from) noexcept
    : StopPlaybackRequest() {
    *this = ::std::move(from);
  }

  inline StopPlaybackRequest& operator=(const StopPlaybackRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPlaybackRequest& operator=(StopPlaybackRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopPlaybackRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopPlaybackRequest* internal_default_instance() {
    return reinterpret_cast<const StopPlaybackRequest*>(
               &_StopPlaybackRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StopPlaybackRequest& a, StopPlaybackRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPlaybackRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopPlaybackRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopPlaybackRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopPlaybackRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopPlaybackRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StopPlaybackRequest& from) {
    StopPlaybackRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopPlaybackRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.StopPlaybackRequest";
  }
  protected:
  explicit StopPlaybackRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.StopPlaybackRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class StopPlaybackResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:fs.StopPlaybackResponse) */ {
 public:
  inline StopPlaybackResponse() : StopPlaybackResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StopPlaybackResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopPlaybackResponse(const StopPlaybackResponse& from);
  StopPlaybackResponse(StopPlaybackResponse&& from) noexcept
    : StopPlaybackResponse() {
    *this = ::std::move(from);
  }

  inline StopPlaybackResponse& operator=(const StopPlaybackResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopPlaybackResponse& operator=(StopPlaybackResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopPlaybackResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopPlaybackResponse* internal_default_instance() {
    return reinterpret_cast<const StopPlaybackResponse*>(
               &_StopPlaybackResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StopPlaybackResponse& a, StopPlaybackResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StopPlaybackResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopPlaybackResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StopPlaybackResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StopPlaybackResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StopPlaybackResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StopPlaybackResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.StopPlaybackResponse";
  }
  protected:
  explicit StopPlaybackResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:fs.StopPlaybackResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BridgeCallRequest_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BridgeCallRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<BridgeCallRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  BridgeCallRequest_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR BridgeCallRequest_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit BridgeCallRequest_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const BridgeCallRequest_VariablesEntry_DoNotUse& other);
  static const BridgeCallRequest_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const BridgeCallRequest_VariablesEntry_DoNotUse*>(&_BridgeCallRequest_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.BridgeCallRequest.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.BridgeCallRequest.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class BridgeCallRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BridgeCallRequest) */ {
 public:
  inline BridgeCallRequest() : BridgeCallRequest(nullptr) {}
  ~BridgeCallRequest() override;
  explicit PROTOBUF_CONSTEXPR BridgeCallRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BridgeCallRequest(const BridgeCallRequest& from);
  BridgeCallRequest(BridgeCallRequest&& from) noexcept
    : BridgeCallRequest() {
    *this = ::std::move(from);
  }

  inline BridgeCallRequest& operator=(const BridgeCallRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeCallRequest& operator=(BridgeCallRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BridgeCallRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BridgeCallRequest* internal_default_instance() {
    return reinterpret_cast<const BridgeCallRequest*>(
               &_BridgeCallRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BridgeCallRequest& a, BridgeCallRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BridgeCallRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeCallRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BridgeCallRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BridgeCallRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BridgeCallRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BridgeCallRequest& from) {
    BridgeCallRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BridgeCallRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BridgeCallRequest";
  }
  protected:
  explicit BridgeCallRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 3,
    kLegAIdFieldNumber = 1,
    kLegBIdFieldNumber = 2,
  };
  // map<string, string> variables = 3;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string leg_a_id = 1;
  void clear_leg_a_id();
  const std::string& leg_a_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leg_a_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leg_a_id();
  PROTOBUF_NODISCARD std::string* release_leg_a_id();
  void set_allocated_leg_a_id(std::string* leg_a_id);
  private:
  const std::string& _internal_leg_a_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leg_a_id(const std::string& value);
  std::string* _internal_mutable_leg_a_id();
  public:

  // string leg_b_id = 2;
  void clear_leg_b_id();
  const std::string& leg_b_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leg_b_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leg_b_id();
  PROTOBUF_NODISCARD std::string* release_leg_b_id();
  void set_allocated_leg_b_id(std::string* leg_b_id);
  private:
  const std::string& _internal_leg_b_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leg_b_id(const std::string& value);
  std::string* _internal_mutable_leg_b_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.BridgeCallRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        BridgeCallRequest_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leg_a_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leg_b_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BridgeCallResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BridgeCallResponse) */ {
 public:
  inline BridgeCallResponse() : BridgeCallResponse(nullptr) {}
  ~BridgeCallResponse() override;
  explicit PROTOBUF_CONSTEXPR BridgeCallResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BridgeCallResponse(const BridgeCallResponse& from);
  BridgeCallResponse(BridgeCallResponse&& from) noexcept
    : BridgeCallResponse() {
    *this = ::std::move(from);
  }

  inline BridgeCallResponse& operator=(const BridgeCallResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeCallResponse& operator=(BridgeCallResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BridgeCallResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BridgeCallResponse* internal_default_instance() {
    return reinterpret_cast<const BridgeCallResponse*>(
               &_BridgeCallResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BridgeCallResponse& a, BridgeCallResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BridgeCallResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeCallResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BridgeCallResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BridgeCallResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BridgeCallResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BridgeCallResponse& from) {
    BridgeCallResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BridgeCallResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BridgeCallResponse";
  }
  protected:
  explicit BridgeCallResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .fs.ErrorExecute error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.BridgeCallResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HoldRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.HoldRequest) */ {
 public:
  inline HoldRequest() : HoldRequest(nullptr) {}
  ~HoldRequest() override;
  explicit PROTOBUF_CONSTEXPR HoldRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HoldRequest(const HoldRequest& from);
  HoldRequest(HoldRequest&& from) noexcept
    : HoldRequest() {
    *this = ::std::move(from);
  }

  inline HoldRequest& operator=(const HoldRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HoldRequest& operator=(HoldRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HoldRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HoldRequest* internal_default_instance() {
    return reinterpret_cast<const HoldRequest*>(
               &_HoldRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(HoldRequest& a, HoldRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HoldRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HoldRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HoldRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HoldRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HoldRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HoldRequest& from) {
    HoldRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HoldRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.HoldRequest";
  }
  protected:
  explicit HoldRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, size_t size);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();
  private:
  const std::string& _internal_id(int index) const;
  std::string* _internal_add_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.HoldRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HoldResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.HoldResponse) */ {
 public:
  inline HoldResponse() : HoldResponse(nullptr) {}
  ~HoldResponse() override;
  explicit PROTOBUF_CONSTEXPR HoldResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HoldResponse(const HoldResponse& from);
  HoldResponse(HoldResponse&& from) noexcept
    : HoldResponse() {
    *this = ::std::move(from);
  }

  inline HoldResponse& operator=(const HoldResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HoldResponse& operator=(HoldResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HoldResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HoldResponse* internal_default_instance() {
    return reinterpret_cast<const HoldResponse*>(
               &_HoldResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(HoldResponse& a, HoldResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HoldResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HoldResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HoldResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HoldResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HoldResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HoldResponse& from) {
    HoldResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HoldResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.HoldResponse";
  }
  protected:
  explicit HoldResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, size_t size);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();
  private:
  const std::string& _internal_id(int index) const;
  std::string* _internal_add_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.HoldResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class UnHoldRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.UnHoldRequest) */ {
 public:
  inline UnHoldRequest() : UnHoldRequest(nullptr) {}
  ~UnHoldRequest() override;
  explicit PROTOBUF_CONSTEXPR UnHoldRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnHoldRequest(const UnHoldRequest& from);
  UnHoldRequest(UnHoldRequest&& from) noexcept
    : UnHoldRequest() {
    *this = ::std::move(from);
  }

  inline UnHoldRequest& operator=(const UnHoldRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnHoldRequest& operator=(UnHoldRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnHoldRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnHoldRequest* internal_default_instance() {
    return reinterpret_cast<const UnHoldRequest*>(
               &_UnHoldRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UnHoldRequest& a, UnHoldRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnHoldRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnHoldRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnHoldRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnHoldRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnHoldRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnHoldRequest& from) {
    UnHoldRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnHoldRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.UnHoldRequest";
  }
  protected:
  explicit UnHoldRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, size_t size);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();
  private:
  const std::string& _internal_id(int index) const;
  std::string* _internal_add_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.UnHoldRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class UnHoldResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.UnHoldResponse) */ {
 public:
  inline UnHoldResponse() : UnHoldResponse(nullptr) {}
  ~UnHoldResponse() override;
  explicit PROTOBUF_CONSTEXPR UnHoldResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnHoldResponse(const UnHoldResponse& from);
  UnHoldResponse(UnHoldResponse&& from) noexcept
    : UnHoldResponse() {
    *this = ::std::move(from);
  }

  inline UnHoldResponse& operator=(const UnHoldResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnHoldResponse& operator=(UnHoldResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnHoldResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnHoldResponse* internal_default_instance() {
    return reinterpret_cast<const UnHoldResponse*>(
               &_UnHoldResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UnHoldResponse& a, UnHoldResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UnHoldResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnHoldResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnHoldResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnHoldResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnHoldResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UnHoldResponse& from) {
    UnHoldResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnHoldResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.UnHoldResponse";
  }
  protected:
  explicit UnHoldResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, size_t size);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();
  private:
  const std::string& _internal_id(int index) const;
  std::string* _internal_add_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.UnHoldResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HangupManyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.HangupManyRequest) */ {
 public:
  inline HangupManyRequest() : HangupManyRequest(nullptr) {}
  ~HangupManyRequest() override;
  explicit PROTOBUF_CONSTEXPR HangupManyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HangupManyRequest(const HangupManyRequest& from);
  HangupManyRequest(HangupManyRequest&& from) noexcept
    : HangupManyRequest() {
    *this = ::std::move(from);
  }

  inline HangupManyRequest& operator=(const HangupManyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HangupManyRequest& operator=(HangupManyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HangupManyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HangupManyRequest* internal_default_instance() {
    return reinterpret_cast<const HangupManyRequest*>(
               &_HangupManyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(HangupManyRequest& a, HangupManyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HangupManyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HangupManyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HangupManyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HangupManyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HangupManyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HangupManyRequest& from) {
    HangupManyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HangupManyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.HangupManyRequest";
  }
  protected:
  explicit HangupManyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kCauseFieldNumber = 2,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, size_t size);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();
  private:
  const std::string& _internal_id(int index) const;
  std::string* _internal_add_id();
  public:

  // string cause = 2;
  void clear_cause();
  const std::string& cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cause();
  PROTOBUF_NODISCARD std::string* release_cause();
  void set_allocated_cause(std::string* cause);
  private:
  const std::string& _internal_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cause(const std::string& value);
  std::string* _internal_mutable_cause();
  public:

  // @@protoc_insertion_point(class_scope:fs.HangupManyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cause_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HangupManyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.HangupManyResponse) */ {
 public:
  inline HangupManyResponse() : HangupManyResponse(nullptr) {}
  ~HangupManyResponse() override;
  explicit PROTOBUF_CONSTEXPR HangupManyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HangupManyResponse(const HangupManyResponse& from);
  HangupManyResponse(HangupManyResponse&& from) noexcept
    : HangupManyResponse() {
    *this = ::std::move(from);
  }

  inline HangupManyResponse& operator=(const HangupManyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HangupManyResponse& operator=(HangupManyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HangupManyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HangupManyResponse* internal_default_instance() {
    return reinterpret_cast<const HangupManyResponse*>(
               &_HangupManyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(HangupManyResponse& a, HangupManyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HangupManyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HangupManyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HangupManyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HangupManyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HangupManyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HangupManyResponse& from) {
    HangupManyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HangupManyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.HangupManyResponse";
  }
  protected:
  explicit HangupManyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // repeated string id = 1;
  int id_size() const;
  private:
  int _internal_id_size() const;
  public:
  void clear_id();
  const std::string& id(int index) const;
  std::string* mutable_id(int index);
  void set_id(int index, const std::string& value);
  void set_id(int index, std::string&& value);
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, size_t size);
  std::string* add_id();
  void add_id(const std::string& value);
  void add_id(std::string&& value);
  void add_id(const char* value);
  void add_id(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();
  private:
  const std::string& _internal_id(int index) const;
  std::string* _internal_add_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.HangupManyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class QueueRequest_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueueRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<QueueRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  QueueRequest_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR QueueRequest_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit QueueRequest_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const QueueRequest_VariablesEntry_DoNotUse& other);
  static const QueueRequest_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const QueueRequest_VariablesEntry_DoNotUse*>(&_QueueRequest_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.QueueRequest.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.QueueRequest.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class QueueRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.QueueRequest) */ {
 public:
  inline QueueRequest() : QueueRequest(nullptr) {}
  ~QueueRequest() override;
  explicit PROTOBUF_CONSTEXPR QueueRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueueRequest(const QueueRequest& from);
  QueueRequest(QueueRequest&& from) noexcept
    : QueueRequest() {
    *this = ::std::move(from);
  }

  inline QueueRequest& operator=(const QueueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueueRequest& operator=(QueueRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueueRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueueRequest* internal_default_instance() {
    return reinterpret_cast<const QueueRequest*>(
               &_QueueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(QueueRequest& a, QueueRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueueRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueueRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueueRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueueRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueueRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueueRequest& from) {
    QueueRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueueRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.QueueRequest";
  }
  protected:
  explicit QueueRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 2,
    kIdFieldNumber = 1,
    kPlaybackFileFieldNumber = 3,
    kPlaybackArgsFieldNumber = 4,
  };
  // map<string, string> variables = 2;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string playback_file = 3;
  void clear_playback_file();
  const std::string& playback_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playback_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playback_file();
  PROTOBUF_NODISCARD std::string* release_playback_file();
  void set_allocated_playback_file(std::string* playback_file);
  private:
  const std::string& _internal_playback_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playback_file(const std::string& value);
  std::string* _internal_mutable_playback_file();
  public:

  // int32 playback_args = 4;
  void clear_playback_args();
  int32_t playback_args() const;
  void set_playback_args(int32_t value);
  private:
  int32_t _internal_playback_args() const;
  void _internal_set_playback_args(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:fs.QueueRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        QueueRequest_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playback_file_;
    int32_t playback_args_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class QueueResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.QueueResponse) */ {
 public:
  inline QueueResponse() : QueueResponse(nullptr) {}
  ~QueueResponse() override;
  explicit PROTOBUF_CONSTEXPR QueueResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueueResponse(const QueueResponse& from);
  QueueResponse(QueueResponse&& from) noexcept
    : QueueResponse() {
    *this = ::std::move(from);
  }

  inline QueueResponse& operator=(const QueueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueueResponse& operator=(QueueResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueueResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueueResponse* internal_default_instance() {
    return reinterpret_cast<const QueueResponse*>(
               &_QueueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(QueueResponse& a, QueueResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueueResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueueResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueueResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueueResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueueResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueueResponse& from) {
    QueueResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueueResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.QueueResponse";
  }
  protected:
  explicit QueueResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // .fs.ErrorExecute error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.QueueResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ErrorExecute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.ErrorExecute) */ {
 public:
  inline ErrorExecute() : ErrorExecute(nullptr) {}
  ~ErrorExecute() override;
  explicit PROTOBUF_CONSTEXPR ErrorExecute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorExecute(const ErrorExecute& from);
  ErrorExecute(ErrorExecute&& from) noexcept
    : ErrorExecute() {
    *this = ::std::move(from);
  }

  inline ErrorExecute& operator=(const ErrorExecute& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorExecute& operator=(ErrorExecute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorExecute& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorExecute* internal_default_instance() {
    return reinterpret_cast<const ErrorExecute*>(
               &_ErrorExecute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(ErrorExecute& a, ErrorExecute& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorExecute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorExecute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorExecute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorExecute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorExecute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorExecute& from) {
    ErrorExecute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorExecute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.ErrorExecute";
  }
  protected:
  explicit ErrorExecute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ErrorExecute_Type Type;
  static constexpr Type ERROR =
    ErrorExecute_Type_ERROR;
  static constexpr Type USAGE =
    ErrorExecute_Type_USAGE;
  static inline bool Type_IsValid(int value) {
    return ErrorExecute_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ErrorExecute_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ErrorExecute_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ErrorExecute_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ErrorExecute_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ErrorExecute_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return ErrorExecute_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .fs.ErrorExecute.Type type = 2;
  void clear_type();
  ::fs::ErrorExecute_Type type() const;
  void set_type(::fs::ErrorExecute_Type value);
  private:
  ::fs::ErrorExecute_Type _internal_type() const;
  void _internal_set_type(::fs::ErrorExecute_Type value);
  public:

  // @@protoc_insertion_point(class_scope:fs.ErrorExecute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ExecuteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.ExecuteRequest) */ {
 public:
  inline ExecuteRequest() : ExecuteRequest(nullptr) {}
  ~ExecuteRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteRequest(const ExecuteRequest& from);
  ExecuteRequest(ExecuteRequest&& from) noexcept
    : ExecuteRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteRequest& operator=(const ExecuteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteRequest& operator=(ExecuteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteRequest*>(
               &_ExecuteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ExecuteRequest& a, ExecuteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteRequest& from) {
    ExecuteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.ExecuteRequest";
  }
  protected:
  explicit ExecuteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommandFieldNumber = 1,
    kArgsFieldNumber = 2,
  };
  // string command = 1;
  void clear_command();
  const std::string& command() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_command(ArgT0&& arg0, ArgT... args);
  std::string* mutable_command();
  PROTOBUF_NODISCARD std::string* release_command();
  void set_allocated_command(std::string* command);
  private:
  const std::string& _internal_command() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_command(const std::string& value);
  std::string* _internal_mutable_command();
  public:

  // string args = 2;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // @@protoc_insertion_point(class_scope:fs.ExecuteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr command_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class ExecuteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.ExecuteResponse) */ {
 public:
  inline ExecuteResponse() : ExecuteResponse(nullptr) {}
  ~ExecuteResponse() override;
  explicit PROTOBUF_CONSTEXPR ExecuteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteResponse(const ExecuteResponse& from);
  ExecuteResponse(ExecuteResponse&& from) noexcept
    : ExecuteResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteResponse& operator=(const ExecuteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteResponse& operator=(ExecuteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteResponse*>(
               &_ExecuteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ExecuteResponse& a, ExecuteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecuteResponse& from) {
    ExecuteResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.ExecuteResponse";
  }
  protected:
  explicit ExecuteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .fs.ErrorExecute error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.ExecuteResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HangupRequest_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HangupRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HangupRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HangupRequest_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HangupRequest_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HangupRequest_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HangupRequest_VariablesEntry_DoNotUse& other);
  static const HangupRequest_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HangupRequest_VariablesEntry_DoNotUse*>(&_HangupRequest_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.HangupRequest.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.HangupRequest.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class HangupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.HangupRequest) */ {
 public:
  inline HangupRequest() : HangupRequest(nullptr) {}
  ~HangupRequest() override;
  explicit PROTOBUF_CONSTEXPR HangupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HangupRequest(const HangupRequest& from);
  HangupRequest(HangupRequest&& from) noexcept
    : HangupRequest() {
    *this = ::std::move(from);
  }

  inline HangupRequest& operator=(const HangupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HangupRequest& operator=(HangupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HangupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HangupRequest* internal_default_instance() {
    return reinterpret_cast<const HangupRequest*>(
               &_HangupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(HangupRequest& a, HangupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HangupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HangupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HangupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HangupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HangupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HangupRequest& from) {
    HangupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HangupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.HangupRequest";
  }
  protected:
  explicit HangupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 4,
    kUuidFieldNumber = 1,
    kCauseFieldNumber = 2,
    kReportingFieldNumber = 3,
  };
  // map<string, string> variables = 4;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // string cause = 2;
  void clear_cause();
  const std::string& cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cause();
  PROTOBUF_NODISCARD std::string* release_cause();
  void set_allocated_cause(std::string* cause);
  private:
  const std::string& _internal_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cause(const std::string& value);
  std::string* _internal_mutable_cause();
  public:

  // bool reporting = 3;
  void clear_reporting();
  bool reporting() const;
  void set_reporting(bool value);
  private:
  bool _internal_reporting() const;
  void _internal_set_reporting(bool value);
  public:

  // @@protoc_insertion_point(class_scope:fs.HangupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HangupRequest_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cause_;
    bool reporting_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HangupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.HangupResponse) */ {
 public:
  inline HangupResponse() : HangupResponse(nullptr) {}
  ~HangupResponse() override;
  explicit PROTOBUF_CONSTEXPR HangupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HangupResponse(const HangupResponse& from);
  HangupResponse(HangupResponse&& from) noexcept
    : HangupResponse() {
    *this = ::std::move(from);
  }

  inline HangupResponse& operator=(const HangupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HangupResponse& operator=(HangupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HangupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HangupResponse* internal_default_instance() {
    return reinterpret_cast<const HangupResponse*>(
               &_HangupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(HangupResponse& a, HangupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HangupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HangupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HangupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HangupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HangupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HangupResponse& from) {
    HangupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HangupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.HangupResponse";
  }
  protected:
  explicit HangupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // .fs.ErrorExecute error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.HangupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class OriginateRequest_Extension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.OriginateRequest.Extension) */ {
 public:
  inline OriginateRequest_Extension() : OriginateRequest_Extension(nullptr) {}
  ~OriginateRequest_Extension() override;
  explicit PROTOBUF_CONSTEXPR OriginateRequest_Extension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OriginateRequest_Extension(const OriginateRequest_Extension& from);
  OriginateRequest_Extension(OriginateRequest_Extension&& from) noexcept
    : OriginateRequest_Extension() {
    *this = ::std::move(from);
  }

  inline OriginateRequest_Extension& operator=(const OriginateRequest_Extension& from) {
    CopyFrom(from);
    return *this;
  }
  inline OriginateRequest_Extension& operator=(OriginateRequest_Extension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OriginateRequest_Extension& default_instance() {
    return *internal_default_instance();
  }
  static inline const OriginateRequest_Extension* internal_default_instance() {
    return reinterpret_cast<const OriginateRequest_Extension*>(
               &_OriginateRequest_Extension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(OriginateRequest_Extension& a, OriginateRequest_Extension& b) {
    a.Swap(&b);
  }
  inline void Swap(OriginateRequest_Extension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OriginateRequest_Extension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OriginateRequest_Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OriginateRequest_Extension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OriginateRequest_Extension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OriginateRequest_Extension& from) {
    OriginateRequest_Extension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OriginateRequest_Extension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.OriginateRequest.Extension";
  }
  protected:
  explicit OriginateRequest_Extension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppNameFieldNumber = 1,
    kArgsFieldNumber = 2,
  };
  // string appName = 1;
  void clear_appname();
  const std::string& appname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_appname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_appname();
  PROTOBUF_NODISCARD std::string* release_appname();
  void set_allocated_appname(std::string* appname);
  private:
  const std::string& _internal_appname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_appname(const std::string& value);
  std::string* _internal_mutable_appname();
  public:

  // string args = 2;
  void clear_args();
  const std::string& args() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_args(ArgT0&& arg0, ArgT... args);
  std::string* mutable_args();
  PROTOBUF_NODISCARD std::string* release_args();
  void set_allocated_args(std::string* args);
  private:
  const std::string& _internal_args() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_args(const std::string& value);
  std::string* _internal_mutable_args();
  public:

  // @@protoc_insertion_point(class_scope:fs.OriginateRequest.Extension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr appname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr args_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class OriginateRequest_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OriginateRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OriginateRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  OriginateRequest_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR OriginateRequest_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit OriginateRequest_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OriginateRequest_VariablesEntry_DoNotUse& other);
  static const OriginateRequest_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OriginateRequest_VariablesEntry_DoNotUse*>(&_OriginateRequest_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.OriginateRequest.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.OriginateRequest.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class OriginateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.OriginateRequest) */ {
 public:
  inline OriginateRequest() : OriginateRequest(nullptr) {}
  ~OriginateRequest() override;
  explicit PROTOBUF_CONSTEXPR OriginateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OriginateRequest(const OriginateRequest& from);
  OriginateRequest(OriginateRequest&& from) noexcept
    : OriginateRequest() {
    *this = ::std::move(from);
  }

  inline OriginateRequest& operator=(const OriginateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OriginateRequest& operator=(OriginateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OriginateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OriginateRequest* internal_default_instance() {
    return reinterpret_cast<const OriginateRequest*>(
               &_OriginateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(OriginateRequest& a, OriginateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OriginateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OriginateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OriginateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OriginateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OriginateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OriginateRequest& from) {
    OriginateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OriginateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.OriginateRequest";
  }
  protected:
  explicit OriginateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OriginateRequest_Extension Extension;

  typedef OriginateRequest_Strategy Strategy;
  static constexpr Strategy FAILOVER =
    OriginateRequest_Strategy_FAILOVER;
  static constexpr Strategy MULTIPLE =
    OriginateRequest_Strategy_MULTIPLE;
  static inline bool Strategy_IsValid(int value) {
    return OriginateRequest_Strategy_IsValid(value);
  }
  static constexpr Strategy Strategy_MIN =
    OriginateRequest_Strategy_Strategy_MIN;
  static constexpr Strategy Strategy_MAX =
    OriginateRequest_Strategy_Strategy_MAX;
  static constexpr int Strategy_ARRAYSIZE =
    OriginateRequest_Strategy_Strategy_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Strategy_descriptor() {
    return OriginateRequest_Strategy_descriptor();
  }
  template<typename T>
  static inline const std::string& Strategy_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Strategy>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Strategy_Name.");
    return OriginateRequest_Strategy_Name(enum_t_value);
  }
  static inline bool Strategy_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Strategy* value) {
    return OriginateRequest_Strategy_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 1,
    kEndpointsFieldNumber = 2,
    kExtensionsFieldNumber = 10,
    kDestinationFieldNumber = 4,
    kCallerNumberFieldNumber = 6,
    kCallerNameFieldNumber = 7,
    kContextFieldNumber = 8,
    kDialplanFieldNumber = 9,
    kCheckIdFieldNumber = 11,
    kStrategyFieldNumber = 3,
    kTimeoutFieldNumber = 5,
  };
  // map<string, string> variables = 1;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // repeated string endpoints = 2;
  int endpoints_size() const;
  private:
  int _internal_endpoints_size() const;
  public:
  void clear_endpoints();
  const std::string& endpoints(int index) const;
  std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const std::string& value);
  void set_endpoints(int index, std::string&& value);
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  std::string* add_endpoints();
  void add_endpoints(const std::string& value);
  void add_endpoints(std::string&& value);
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& endpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_endpoints();
  private:
  const std::string& _internal_endpoints(int index) const;
  std::string* _internal_add_endpoints();
  public:

  // repeated .fs.OriginateRequest.Extension extensions = 10;
  int extensions_size() const;
  private:
  int _internal_extensions_size() const;
  public:
  void clear_extensions();
  ::fs::OriginateRequest_Extension* mutable_extensions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fs::OriginateRequest_Extension >*
      mutable_extensions();
  private:
  const ::fs::OriginateRequest_Extension& _internal_extensions(int index) const;
  ::fs::OriginateRequest_Extension* _internal_add_extensions();
  public:
  const ::fs::OriginateRequest_Extension& extensions(int index) const;
  ::fs::OriginateRequest_Extension* add_extensions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fs::OriginateRequest_Extension >&
      extensions() const;

  // string destination = 4;
  void clear_destination();
  const std::string& destination() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_destination(ArgT0&& arg0, ArgT... args);
  std::string* mutable_destination();
  PROTOBUF_NODISCARD std::string* release_destination();
  void set_allocated_destination(std::string* destination);
  private:
  const std::string& _internal_destination() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_destination(const std::string& value);
  std::string* _internal_mutable_destination();
  public:

  // string callerNumber = 6;
  void clear_callernumber();
  const std::string& callernumber() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_callernumber(ArgT0&& arg0, ArgT... args);
  std::string* mutable_callernumber();
  PROTOBUF_NODISCARD std::string* release_callernumber();
  void set_allocated_callernumber(std::string* callernumber);
  private:
  const std::string& _internal_callernumber() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callernumber(const std::string& value);
  std::string* _internal_mutable_callernumber();
  public:

  // string callerName = 7;
  void clear_callername();
  const std::string& callername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_callername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_callername();
  PROTOBUF_NODISCARD std::string* release_callername();
  void set_allocated_callername(std::string* callername);
  private:
  const std::string& _internal_callername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_callername(const std::string& value);
  std::string* _internal_mutable_callername();
  public:

  // string context = 8;
  void clear_context();
  const std::string& context() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_context(ArgT0&& arg0, ArgT... args);
  std::string* mutable_context();
  PROTOBUF_NODISCARD std::string* release_context();
  void set_allocated_context(std::string* context);
  private:
  const std::string& _internal_context() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_context(const std::string& value);
  std::string* _internal_mutable_context();
  public:

  // string dialplan = 9;
  void clear_dialplan();
  const std::string& dialplan() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_dialplan(ArgT0&& arg0, ArgT... args);
  std::string* mutable_dialplan();
  PROTOBUF_NODISCARD std::string* release_dialplan();
  void set_allocated_dialplan(std::string* dialplan);
  private:
  const std::string& _internal_dialplan() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_dialplan(const std::string& value);
  std::string* _internal_mutable_dialplan();
  public:

  // string check_id = 11;
  void clear_check_id();
  const std::string& check_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_check_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_check_id();
  PROTOBUF_NODISCARD std::string* release_check_id();
  void set_allocated_check_id(std::string* check_id);
  private:
  const std::string& _internal_check_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_check_id(const std::string& value);
  std::string* _internal_mutable_check_id();
  public:

  // .fs.OriginateRequest.Strategy strategy = 3;
  void clear_strategy();
  ::fs::OriginateRequest_Strategy strategy() const;
  void set_strategy(::fs::OriginateRequest_Strategy value);
  private:
  ::fs::OriginateRequest_Strategy _internal_strategy() const;
  void _internal_set_strategy(::fs::OriginateRequest_Strategy value);
  public:

  // int32 timeout = 5;
  void clear_timeout();
  int32_t timeout() const;
  void set_timeout(int32_t value);
  private:
  int32_t _internal_timeout() const;
  void _internal_set_timeout(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:fs.OriginateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        OriginateRequest_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> endpoints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fs::OriginateRequest_Extension > extensions_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr destination_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callernumber_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr callername_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr context_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr dialplan_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr check_id_;
    int strategy_;
    int32_t timeout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class OriginateResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.OriginateResponse) */ {
 public:
  inline OriginateResponse() : OriginateResponse(nullptr) {}
  ~OriginateResponse() override;
  explicit PROTOBUF_CONSTEXPR OriginateResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OriginateResponse(const OriginateResponse& from);
  OriginateResponse(OriginateResponse&& from) noexcept
    : OriginateResponse() {
    *this = ::std::move(from);
  }

  inline OriginateResponse& operator=(const OriginateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline OriginateResponse& operator=(OriginateResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OriginateResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const OriginateResponse* internal_default_instance() {
    return reinterpret_cast<const OriginateResponse*>(
               &_OriginateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(OriginateResponse& a, OriginateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(OriginateResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OriginateResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OriginateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OriginateResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OriginateResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OriginateResponse& from) {
    OriginateResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OriginateResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.OriginateResponse";
  }
  protected:
  explicit OriginateResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kErrorFieldNumber = 2,
    kErrorCodeFieldNumber = 3,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .fs.ErrorExecute error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // int32 error_code = 3;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:fs.OriginateResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::fs::ErrorExecute* error_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BridgeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BridgeRequest) */ {
 public:
  inline BridgeRequest() : BridgeRequest(nullptr) {}
  ~BridgeRequest() override;
  explicit PROTOBUF_CONSTEXPR BridgeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BridgeRequest(const BridgeRequest& from);
  BridgeRequest(BridgeRequest&& from) noexcept
    : BridgeRequest() {
    *this = ::std::move(from);
  }

  inline BridgeRequest& operator=(const BridgeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeRequest& operator=(BridgeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BridgeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BridgeRequest* internal_default_instance() {
    return reinterpret_cast<const BridgeRequest*>(
               &_BridgeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(BridgeRequest& a, BridgeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BridgeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BridgeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BridgeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BridgeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BridgeRequest& from) {
    BridgeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BridgeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BridgeRequest";
  }
  protected:
  explicit BridgeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegAIdFieldNumber = 1,
    kLegBIdFieldNumber = 2,
    kLegBReserveIdFieldNumber = 3,
  };
  // string leg_a_id = 1;
  void clear_leg_a_id();
  const std::string& leg_a_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leg_a_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leg_a_id();
  PROTOBUF_NODISCARD std::string* release_leg_a_id();
  void set_allocated_leg_a_id(std::string* leg_a_id);
  private:
  const std::string& _internal_leg_a_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leg_a_id(const std::string& value);
  std::string* _internal_mutable_leg_a_id();
  public:

  // string leg_b_id = 2;
  void clear_leg_b_id();
  const std::string& leg_b_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leg_b_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leg_b_id();
  PROTOBUF_NODISCARD std::string* release_leg_b_id();
  void set_allocated_leg_b_id(std::string* leg_b_id);
  private:
  const std::string& _internal_leg_b_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leg_b_id(const std::string& value);
  std::string* _internal_mutable_leg_b_id();
  public:

  // string leg_b_reserve_id = 3;
  void clear_leg_b_reserve_id();
  const std::string& leg_b_reserve_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_leg_b_reserve_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_leg_b_reserve_id();
  PROTOBUF_NODISCARD std::string* release_leg_b_reserve_id();
  void set_allocated_leg_b_reserve_id(std::string* leg_b_reserve_id);
  private:
  const std::string& _internal_leg_b_reserve_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_leg_b_reserve_id(const std::string& value);
  std::string* _internal_mutable_leg_b_reserve_id();
  public:

  // @@protoc_insertion_point(class_scope:fs.BridgeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leg_a_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leg_b_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr leg_b_reserve_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class BridgeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.BridgeResponse) */ {
 public:
  inline BridgeResponse() : BridgeResponse(nullptr) {}
  ~BridgeResponse() override;
  explicit PROTOBUF_CONSTEXPR BridgeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BridgeResponse(const BridgeResponse& from);
  BridgeResponse(BridgeResponse&& from) noexcept
    : BridgeResponse() {
    *this = ::std::move(from);
  }

  inline BridgeResponse& operator=(const BridgeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BridgeResponse& operator=(BridgeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BridgeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BridgeResponse* internal_default_instance() {
    return reinterpret_cast<const BridgeResponse*>(
               &_BridgeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(BridgeResponse& a, BridgeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BridgeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BridgeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BridgeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BridgeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BridgeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BridgeResponse& from) {
    BridgeResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BridgeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.BridgeResponse";
  }
  protected:
  explicit BridgeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUuidFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // .fs.ErrorExecute error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.BridgeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class SetVariablesRequest_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetVariablesRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SetVariablesRequest_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  SetVariablesRequest_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SetVariablesRequest_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SetVariablesRequest_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SetVariablesRequest_VariablesEntry_DoNotUse& other);
  static const SetVariablesRequest_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SetVariablesRequest_VariablesEntry_DoNotUse*>(&_SetVariablesRequest_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.SetVariablesRequest.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.SetVariablesRequest.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class SetVariablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.SetVariablesRequest) */ {
 public:
  inline SetVariablesRequest() : SetVariablesRequest(nullptr) {}
  ~SetVariablesRequest() override;
  explicit PROTOBUF_CONSTEXPR SetVariablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVariablesRequest(const SetVariablesRequest& from);
  SetVariablesRequest(SetVariablesRequest&& from) noexcept
    : SetVariablesRequest() {
    *this = ::std::move(from);
  }

  inline SetVariablesRequest& operator=(const SetVariablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVariablesRequest& operator=(SetVariablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVariablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVariablesRequest* internal_default_instance() {
    return reinterpret_cast<const SetVariablesRequest*>(
               &_SetVariablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SetVariablesRequest& a, SetVariablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVariablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVariablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVariablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVariablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVariablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVariablesRequest& from) {
    SetVariablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVariablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.SetVariablesRequest";
  }
  protected:
  explicit SetVariablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 2,
    kUuidFieldNumber = 1,
  };
  // map<string, string> variables = 2;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string uuid = 1;
  void clear_uuid();
  const std::string& uuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uuid();
  PROTOBUF_NODISCARD std::string* release_uuid();
  void set_allocated_uuid(std::string* uuid);
  private:
  const std::string& _internal_uuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uuid(const std::string& value);
  std::string* _internal_mutable_uuid();
  public:

  // @@protoc_insertion_point(class_scope:fs.SetVariablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SetVariablesRequest_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uuid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class SetVariablesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.SetVariablesResponse) */ {
 public:
  inline SetVariablesResponse() : SetVariablesResponse(nullptr) {}
  ~SetVariablesResponse() override;
  explicit PROTOBUF_CONSTEXPR SetVariablesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetVariablesResponse(const SetVariablesResponse& from);
  SetVariablesResponse(SetVariablesResponse&& from) noexcept
    : SetVariablesResponse() {
    *this = ::std::move(from);
  }

  inline SetVariablesResponse& operator=(const SetVariablesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetVariablesResponse& operator=(SetVariablesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetVariablesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetVariablesResponse* internal_default_instance() {
    return reinterpret_cast<const SetVariablesResponse*>(
               &_SetVariablesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(SetVariablesResponse& a, SetVariablesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SetVariablesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetVariablesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetVariablesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetVariablesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SetVariablesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SetVariablesResponse& from) {
    SetVariablesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetVariablesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.SetVariablesResponse";
  }
  protected:
  explicit SetVariablesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorFieldNumber = 1,
  };
  // .fs.ErrorExecute error = 1;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::fs::ErrorExecute& error() const;
  PROTOBUF_NODISCARD ::fs::ErrorExecute* release_error();
  ::fs::ErrorExecute* mutable_error();
  void set_allocated_error(::fs::ErrorExecute* error);
  private:
  const ::fs::ErrorExecute& _internal_error() const;
  ::fs::ErrorExecute* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::fs::ErrorExecute* error);
  ::fs::ErrorExecute* unsafe_arena_release_error();

  // @@protoc_insertion_point(class_scope:fs.SetVariablesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::fs::ErrorExecute* error_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HangupMatchingVarsReqeust_VariablesEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HangupMatchingVarsReqeust_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HangupMatchingVarsReqeust_VariablesEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  HangupMatchingVarsReqeust_VariablesEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HangupMatchingVarsReqeust_VariablesEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HangupMatchingVarsReqeust_VariablesEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HangupMatchingVarsReqeust_VariablesEntry_DoNotUse& other);
  static const HangupMatchingVarsReqeust_VariablesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HangupMatchingVarsReqeust_VariablesEntry_DoNotUse*>(&_HangupMatchingVarsReqeust_VariablesEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.HangupMatchingVarsReqeust.VariablesEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "fs.HangupMatchingVarsReqeust.VariablesEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_fs_2eproto;
};

// -------------------------------------------------------------------

class HangupMatchingVarsReqeust final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.HangupMatchingVarsReqeust) */ {
 public:
  inline HangupMatchingVarsReqeust() : HangupMatchingVarsReqeust(nullptr) {}
  ~HangupMatchingVarsReqeust() override;
  explicit PROTOBUF_CONSTEXPR HangupMatchingVarsReqeust(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HangupMatchingVarsReqeust(const HangupMatchingVarsReqeust& from);
  HangupMatchingVarsReqeust(HangupMatchingVarsReqeust&& from) noexcept
    : HangupMatchingVarsReqeust() {
    *this = ::std::move(from);
  }

  inline HangupMatchingVarsReqeust& operator=(const HangupMatchingVarsReqeust& from) {
    CopyFrom(from);
    return *this;
  }
  inline HangupMatchingVarsReqeust& operator=(HangupMatchingVarsReqeust&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HangupMatchingVarsReqeust& default_instance() {
    return *internal_default_instance();
  }
  static inline const HangupMatchingVarsReqeust* internal_default_instance() {
    return reinterpret_cast<const HangupMatchingVarsReqeust*>(
               &_HangupMatchingVarsReqeust_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(HangupMatchingVarsReqeust& a, HangupMatchingVarsReqeust& b) {
    a.Swap(&b);
  }
  inline void Swap(HangupMatchingVarsReqeust* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HangupMatchingVarsReqeust* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HangupMatchingVarsReqeust* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HangupMatchingVarsReqeust>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HangupMatchingVarsReqeust& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HangupMatchingVarsReqeust& from) {
    HangupMatchingVarsReqeust::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HangupMatchingVarsReqeust* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.HangupMatchingVarsReqeust";
  }
  protected:
  explicit HangupMatchingVarsReqeust(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVariablesFieldNumber = 2,
    kCauseFieldNumber = 1,
  };
  // map<string, string> variables = 2;
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_variables();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      variables() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_variables();

  // string cause = 1;
  void clear_cause();
  const std::string& cause() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cause(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cause();
  PROTOBUF_NODISCARD std::string* release_cause();
  void set_allocated_cause(std::string* cause);
  private:
  const std::string& _internal_cause() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cause(const std::string& value);
  std::string* _internal_mutable_cause();
  public:

  // @@protoc_insertion_point(class_scope:fs.HangupMatchingVarsReqeust)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HangupMatchingVarsReqeust_VariablesEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cause_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// -------------------------------------------------------------------

class HangupMatchingVarsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:fs.HangupMatchingVarsResponse) */ {
 public:
  inline HangupMatchingVarsResponse() : HangupMatchingVarsResponse(nullptr) {}
  ~HangupMatchingVarsResponse() override;
  explicit PROTOBUF_CONSTEXPR HangupMatchingVarsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HangupMatchingVarsResponse(const HangupMatchingVarsResponse& from);
  HangupMatchingVarsResponse(HangupMatchingVarsResponse&& from) noexcept
    : HangupMatchingVarsResponse() {
    *this = ::std::move(from);
  }

  inline HangupMatchingVarsResponse& operator=(const HangupMatchingVarsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HangupMatchingVarsResponse& operator=(HangupMatchingVarsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HangupMatchingVarsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HangupMatchingVarsResponse* internal_default_instance() {
    return reinterpret_cast<const HangupMatchingVarsResponse*>(
               &_HangupMatchingVarsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(HangupMatchingVarsResponse& a, HangupMatchingVarsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HangupMatchingVarsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HangupMatchingVarsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HangupMatchingVarsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HangupMatchingVarsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HangupMatchingVarsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HangupMatchingVarsResponse& from) {
    HangupMatchingVarsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HangupMatchingVarsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "fs.HangupMatchingVarsResponse";
  }
  protected:
  explicit HangupMatchingVarsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 1,
  };
  // int32 count = 1;
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:fs.HangupMatchingVarsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_fs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// BreakParkRequest

// string id = 1;
inline void BreakParkRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BreakParkRequest::id() const {
  // @@protoc_insertion_point(field_get:fs.BreakParkRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BreakParkRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BreakParkRequest.id)
}
inline std::string* BreakParkRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fs.BreakParkRequest.id)
  return _s;
}
inline const std::string& BreakParkRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BreakParkRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BreakParkRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BreakParkRequest::release_id() {
  // @@protoc_insertion_point(field_release:fs.BreakParkRequest.id)
  return _impl_.id_.Release();
}
inline void BreakParkRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BreakParkRequest.id)
}

// map<string, string> variables = 2;
inline int BreakParkRequest::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int BreakParkRequest::variables_size() const {
  return _internal_variables_size();
}
inline void BreakParkRequest::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BreakParkRequest::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BreakParkRequest::variables() const {
  // @@protoc_insertion_point(field_map:fs.BreakParkRequest.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BreakParkRequest::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BreakParkRequest::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.BreakParkRequest.variables)
  return _internal_mutable_variables();
}

// -------------------------------------------------------------------

// BreakParkResponse

// bool ok = 1;
inline void BreakParkResponse::clear_ok() {
  _impl_.ok_ = false;
}
inline bool BreakParkResponse::_internal_ok() const {
  return _impl_.ok_;
}
inline bool BreakParkResponse::ok() const {
  // @@protoc_insertion_point(field_get:fs.BreakParkResponse.ok)
  return _internal_ok();
}
inline void BreakParkResponse::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void BreakParkResponse::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:fs.BreakParkResponse.ok)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BlindTransferRequest

// string id = 1;
inline void BlindTransferRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BlindTransferRequest::id() const {
  // @@protoc_insertion_point(field_get:fs.BlindTransferRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlindTransferRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BlindTransferRequest.id)
}
inline std::string* BlindTransferRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fs.BlindTransferRequest.id)
  return _s;
}
inline const std::string& BlindTransferRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BlindTransferRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BlindTransferRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BlindTransferRequest::release_id() {
  // @@protoc_insertion_point(field_release:fs.BlindTransferRequest.id)
  return _impl_.id_.Release();
}
inline void BlindTransferRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BlindTransferRequest.id)
}

// string destination = 2;
inline void BlindTransferRequest::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& BlindTransferRequest::destination() const {
  // @@protoc_insertion_point(field_get:fs.BlindTransferRequest.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlindTransferRequest::set_destination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BlindTransferRequest.destination)
}
inline std::string* BlindTransferRequest::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:fs.BlindTransferRequest.destination)
  return _s;
}
inline const std::string& BlindTransferRequest::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void BlindTransferRequest::_internal_set_destination(const std::string& value) {
  
  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* BlindTransferRequest::_internal_mutable_destination() {
  
  return _impl_.destination_.Mutable(GetArenaForAllocation());
}
inline std::string* BlindTransferRequest::release_destination() {
  // @@protoc_insertion_point(field_release:fs.BlindTransferRequest.destination)
  return _impl_.destination_.Release();
}
inline void BlindTransferRequest::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  _impl_.destination_.SetAllocated(destination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_.IsDefault()) {
    _impl_.destination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BlindTransferRequest.destination)
}

// map<string, string> variables = 3;
inline int BlindTransferRequest::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int BlindTransferRequest::variables_size() const {
  return _internal_variables_size();
}
inline void BlindTransferRequest::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BlindTransferRequest::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BlindTransferRequest::variables() const {
  // @@protoc_insertion_point(field_map:fs.BlindTransferRequest.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BlindTransferRequest::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BlindTransferRequest::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.BlindTransferRequest.variables)
  return _internal_mutable_variables();
}

// string dialplan = 4;
inline void BlindTransferRequest::clear_dialplan() {
  _impl_.dialplan_.ClearToEmpty();
}
inline const std::string& BlindTransferRequest::dialplan() const {
  // @@protoc_insertion_point(field_get:fs.BlindTransferRequest.dialplan)
  return _internal_dialplan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlindTransferRequest::set_dialplan(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dialplan_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BlindTransferRequest.dialplan)
}
inline std::string* BlindTransferRequest::mutable_dialplan() {
  std::string* _s = _internal_mutable_dialplan();
  // @@protoc_insertion_point(field_mutable:fs.BlindTransferRequest.dialplan)
  return _s;
}
inline const std::string& BlindTransferRequest::_internal_dialplan() const {
  return _impl_.dialplan_.Get();
}
inline void BlindTransferRequest::_internal_set_dialplan(const std::string& value) {
  
  _impl_.dialplan_.Set(value, GetArenaForAllocation());
}
inline std::string* BlindTransferRequest::_internal_mutable_dialplan() {
  
  return _impl_.dialplan_.Mutable(GetArenaForAllocation());
}
inline std::string* BlindTransferRequest::release_dialplan() {
  // @@protoc_insertion_point(field_release:fs.BlindTransferRequest.dialplan)
  return _impl_.dialplan_.Release();
}
inline void BlindTransferRequest::set_allocated_dialplan(std::string* dialplan) {
  if (dialplan != nullptr) {
    
  } else {
    
  }
  _impl_.dialplan_.SetAllocated(dialplan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dialplan_.IsDefault()) {
    _impl_.dialplan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BlindTransferRequest.dialplan)
}

// string context = 5;
inline void BlindTransferRequest::clear_context() {
  _impl_.context_.ClearToEmpty();
}
inline const std::string& BlindTransferRequest::context() const {
  // @@protoc_insertion_point(field_get:fs.BlindTransferRequest.context)
  return _internal_context();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlindTransferRequest::set_context(ArgT0&& arg0, ArgT... args) {
 
 _impl_.context_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BlindTransferRequest.context)
}
inline std::string* BlindTransferRequest::mutable_context() {
  std::string* _s = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:fs.BlindTransferRequest.context)
  return _s;
}
inline const std::string& BlindTransferRequest::_internal_context() const {
  return _impl_.context_.Get();
}
inline void BlindTransferRequest::_internal_set_context(const std::string& value) {
  
  _impl_.context_.Set(value, GetArenaForAllocation());
}
inline std::string* BlindTransferRequest::_internal_mutable_context() {
  
  return _impl_.context_.Mutable(GetArenaForAllocation());
}
inline std::string* BlindTransferRequest::release_context() {
  // @@protoc_insertion_point(field_release:fs.BlindTransferRequest.context)
  return _impl_.context_.Release();
}
inline void BlindTransferRequest::set_allocated_context(std::string* context) {
  if (context != nullptr) {
    
  } else {
    
  }
  _impl_.context_.SetAllocated(context, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.context_.IsDefault()) {
    _impl_.context_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BlindTransferRequest.context)
}

// -------------------------------------------------------------------

// BlindTransferResponse

// .fs.ErrorExecute error = 1;
inline bool BlindTransferResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool BlindTransferResponse::has_error() const {
  return _internal_has_error();
}
inline void BlindTransferResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& BlindTransferResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& BlindTransferResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.BlindTransferResponse.error)
  return _internal_error();
}
inline void BlindTransferResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.BlindTransferResponse.error)
}
inline ::fs::ErrorExecute* BlindTransferResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* BlindTransferResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.BlindTransferResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* BlindTransferResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* BlindTransferResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.BlindTransferResponse.error)
  return _msg;
}
inline void BlindTransferResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.BlindTransferResponse.error)
}

// -------------------------------------------------------------------

// SetEavesdropStateRequest

// string id = 1;
inline void SetEavesdropStateRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SetEavesdropStateRequest::id() const {
  // @@protoc_insertion_point(field_get:fs.SetEavesdropStateRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetEavesdropStateRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.SetEavesdropStateRequest.id)
}
inline std::string* SetEavesdropStateRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fs.SetEavesdropStateRequest.id)
  return _s;
}
inline const std::string& SetEavesdropStateRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SetEavesdropStateRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetEavesdropStateRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetEavesdropStateRequest::release_id() {
  // @@protoc_insertion_point(field_release:fs.SetEavesdropStateRequest.id)
  return _impl_.id_.Release();
}
inline void SetEavesdropStateRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.SetEavesdropStateRequest.id)
}

// string state = 2;
inline void SetEavesdropStateRequest::clear_state() {
  _impl_.state_.ClearToEmpty();
}
inline const std::string& SetEavesdropStateRequest::state() const {
  // @@protoc_insertion_point(field_get:fs.SetEavesdropStateRequest.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetEavesdropStateRequest::set_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.state_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.SetEavesdropStateRequest.state)
}
inline std::string* SetEavesdropStateRequest::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:fs.SetEavesdropStateRequest.state)
  return _s;
}
inline const std::string& SetEavesdropStateRequest::_internal_state() const {
  return _impl_.state_.Get();
}
inline void SetEavesdropStateRequest::_internal_set_state(const std::string& value) {
  
  _impl_.state_.Set(value, GetArenaForAllocation());
}
inline std::string* SetEavesdropStateRequest::_internal_mutable_state() {
  
  return _impl_.state_.Mutable(GetArenaForAllocation());
}
inline std::string* SetEavesdropStateRequest::release_state() {
  // @@protoc_insertion_point(field_release:fs.SetEavesdropStateRequest.state)
  return _impl_.state_.Release();
}
inline void SetEavesdropStateRequest::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  _impl_.state_.SetAllocated(state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.state_.IsDefault()) {
    _impl_.state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.SetEavesdropStateRequest.state)
}

// -------------------------------------------------------------------

// SetEavesdropStateResponse

// .fs.ErrorExecute error = 1;
inline bool SetEavesdropStateResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool SetEavesdropStateResponse::has_error() const {
  return _internal_has_error();
}
inline void SetEavesdropStateResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& SetEavesdropStateResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& SetEavesdropStateResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.SetEavesdropStateResponse.error)
  return _internal_error();
}
inline void SetEavesdropStateResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.SetEavesdropStateResponse.error)
}
inline ::fs::ErrorExecute* SetEavesdropStateResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* SetEavesdropStateResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.SetEavesdropStateResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* SetEavesdropStateResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* SetEavesdropStateResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.SetEavesdropStateResponse.error)
  return _msg;
}
inline void SetEavesdropStateResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.SetEavesdropStateResponse.error)
}

// -------------------------------------------------------------------

// BroadcastRequest

// string id = 1;
inline void BroadcastRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BroadcastRequest::id() const {
  // @@protoc_insertion_point(field_get:fs.BroadcastRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BroadcastRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BroadcastRequest.id)
}
inline std::string* BroadcastRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fs.BroadcastRequest.id)
  return _s;
}
inline const std::string& BroadcastRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BroadcastRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BroadcastRequest::release_id() {
  // @@protoc_insertion_point(field_release:fs.BroadcastRequest.id)
  return _impl_.id_.Release();
}
inline void BroadcastRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BroadcastRequest.id)
}

// string args = 2;
inline void BroadcastRequest::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& BroadcastRequest::args() const {
  // @@protoc_insertion_point(field_get:fs.BroadcastRequest.args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BroadcastRequest::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BroadcastRequest.args)
}
inline std::string* BroadcastRequest::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:fs.BroadcastRequest.args)
  return _s;
}
inline const std::string& BroadcastRequest::_internal_args() const {
  return _impl_.args_.Get();
}
inline void BroadcastRequest::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastRequest::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* BroadcastRequest::release_args() {
  // @@protoc_insertion_point(field_release:fs.BroadcastRequest.args)
  return _impl_.args_.Release();
}
inline void BroadcastRequest::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BroadcastRequest.args)
}

// bool wait_for_answer = 3;
inline void BroadcastRequest::clear_wait_for_answer() {
  _impl_.wait_for_answer_ = false;
}
inline bool BroadcastRequest::_internal_wait_for_answer() const {
  return _impl_.wait_for_answer_;
}
inline bool BroadcastRequest::wait_for_answer() const {
  // @@protoc_insertion_point(field_get:fs.BroadcastRequest.wait_for_answer)
  return _internal_wait_for_answer();
}
inline void BroadcastRequest::_internal_set_wait_for_answer(bool value) {
  
  _impl_.wait_for_answer_ = value;
}
inline void BroadcastRequest::set_wait_for_answer(bool value) {
  _internal_set_wait_for_answer(value);
  // @@protoc_insertion_point(field_set:fs.BroadcastRequest.wait_for_answer)
}

// string leg = 4;
inline void BroadcastRequest::clear_leg() {
  _impl_.leg_.ClearToEmpty();
}
inline const std::string& BroadcastRequest::leg() const {
  // @@protoc_insertion_point(field_get:fs.BroadcastRequest.leg)
  return _internal_leg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BroadcastRequest::set_leg(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leg_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BroadcastRequest.leg)
}
inline std::string* BroadcastRequest::mutable_leg() {
  std::string* _s = _internal_mutable_leg();
  // @@protoc_insertion_point(field_mutable:fs.BroadcastRequest.leg)
  return _s;
}
inline const std::string& BroadcastRequest::_internal_leg() const {
  return _impl_.leg_.Get();
}
inline void BroadcastRequest::_internal_set_leg(const std::string& value) {
  
  _impl_.leg_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastRequest::_internal_mutable_leg() {
  
  return _impl_.leg_.Mutable(GetArenaForAllocation());
}
inline std::string* BroadcastRequest::release_leg() {
  // @@protoc_insertion_point(field_release:fs.BroadcastRequest.leg)
  return _impl_.leg_.Release();
}
inline void BroadcastRequest::set_allocated_leg(std::string* leg) {
  if (leg != nullptr) {
    
  } else {
    
  }
  _impl_.leg_.SetAllocated(leg, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leg_.IsDefault()) {
    _impl_.leg_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BroadcastRequest.leg)
}

// -------------------------------------------------------------------

// BroadcastResponse

// string data = 1;
inline void BroadcastResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& BroadcastResponse::data() const {
  // @@protoc_insertion_point(field_get:fs.BroadcastResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BroadcastResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BroadcastResponse.data)
}
inline std::string* BroadcastResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:fs.BroadcastResponse.data)
  return _s;
}
inline const std::string& BroadcastResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void BroadcastResponse::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastResponse::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* BroadcastResponse::release_data() {
  // @@protoc_insertion_point(field_release:fs.BroadcastResponse.data)
  return _impl_.data_.Release();
}
inline void BroadcastResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BroadcastResponse.data)
}

// .fs.ErrorExecute error = 2;
inline bool BroadcastResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool BroadcastResponse::has_error() const {
  return _internal_has_error();
}
inline void BroadcastResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& BroadcastResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& BroadcastResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.BroadcastResponse.error)
  return _internal_error();
}
inline void BroadcastResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.BroadcastResponse.error)
}
inline ::fs::ErrorExecute* BroadcastResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* BroadcastResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.BroadcastResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* BroadcastResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* BroadcastResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.BroadcastResponse.error)
  return _msg;
}
inline void BroadcastResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.BroadcastResponse.error)
}

// -------------------------------------------------------------------

// ConfirmPushRequest

// string id = 1;
inline void ConfirmPushRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConfirmPushRequest::id() const {
  // @@protoc_insertion_point(field_get:fs.ConfirmPushRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmPushRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.ConfirmPushRequest.id)
}
inline std::string* ConfirmPushRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fs.ConfirmPushRequest.id)
  return _s;
}
inline const std::string& ConfirmPushRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConfirmPushRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmPushRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmPushRequest::release_id() {
  // @@protoc_insertion_point(field_release:fs.ConfirmPushRequest.id)
  return _impl_.id_.Release();
}
inline void ConfirmPushRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.ConfirmPushRequest.id)
}

// -------------------------------------------------------------------

// ConfirmPushResponse

// .fs.ErrorExecute error = 1;
inline bool ConfirmPushResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool ConfirmPushResponse::has_error() const {
  return _internal_has_error();
}
inline void ConfirmPushResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& ConfirmPushResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& ConfirmPushResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.ConfirmPushResponse.error)
  return _internal_error();
}
inline void ConfirmPushResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.ConfirmPushResponse.error)
}
inline ::fs::ErrorExecute* ConfirmPushResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* ConfirmPushResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.ConfirmPushResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* ConfirmPushResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* ConfirmPushResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.ConfirmPushResponse.error)
  return _msg;
}
inline void ConfirmPushResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.ConfirmPushResponse.error)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetProfileVarRequest

// string id = 1;
inline void SetProfileVarRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SetProfileVarRequest::id() const {
  // @@protoc_insertion_point(field_get:fs.SetProfileVarRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetProfileVarRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.SetProfileVarRequest.id)
}
inline std::string* SetProfileVarRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fs.SetProfileVarRequest.id)
  return _s;
}
inline const std::string& SetProfileVarRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SetProfileVarRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SetProfileVarRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SetProfileVarRequest::release_id() {
  // @@protoc_insertion_point(field_release:fs.SetProfileVarRequest.id)
  return _impl_.id_.Release();
}
inline void SetProfileVarRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.SetProfileVarRequest.id)
}

// map<string, string> variables = 2;
inline int SetProfileVarRequest::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int SetProfileVarRequest::variables_size() const {
  return _internal_variables_size();
}
inline void SetProfileVarRequest::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SetProfileVarRequest::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SetProfileVarRequest::variables() const {
  // @@protoc_insertion_point(field_map:fs.SetProfileVarRequest.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SetProfileVarRequest::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SetProfileVarRequest::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.SetProfileVarRequest.variables)
  return _internal_mutable_variables();
}

// -------------------------------------------------------------------

// SetProfileVarResponse

// -------------------------------------------------------------------

// StopPlaybackRequest

// string id = 1;
inline void StopPlaybackRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& StopPlaybackRequest::id() const {
  // @@protoc_insertion_point(field_get:fs.StopPlaybackRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StopPlaybackRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.StopPlaybackRequest.id)
}
inline std::string* StopPlaybackRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fs.StopPlaybackRequest.id)
  return _s;
}
inline const std::string& StopPlaybackRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void StopPlaybackRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* StopPlaybackRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* StopPlaybackRequest::release_id() {
  // @@protoc_insertion_point(field_release:fs.StopPlaybackRequest.id)
  return _impl_.id_.Release();
}
inline void StopPlaybackRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.StopPlaybackRequest.id)
}

// -------------------------------------------------------------------

// StopPlaybackResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// BridgeCallRequest

// string leg_a_id = 1;
inline void BridgeCallRequest::clear_leg_a_id() {
  _impl_.leg_a_id_.ClearToEmpty();
}
inline const std::string& BridgeCallRequest::leg_a_id() const {
  // @@protoc_insertion_point(field_get:fs.BridgeCallRequest.leg_a_id)
  return _internal_leg_a_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BridgeCallRequest::set_leg_a_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leg_a_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BridgeCallRequest.leg_a_id)
}
inline std::string* BridgeCallRequest::mutable_leg_a_id() {
  std::string* _s = _internal_mutable_leg_a_id();
  // @@protoc_insertion_point(field_mutable:fs.BridgeCallRequest.leg_a_id)
  return _s;
}
inline const std::string& BridgeCallRequest::_internal_leg_a_id() const {
  return _impl_.leg_a_id_.Get();
}
inline void BridgeCallRequest::_internal_set_leg_a_id(const std::string& value) {
  
  _impl_.leg_a_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BridgeCallRequest::_internal_mutable_leg_a_id() {
  
  return _impl_.leg_a_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BridgeCallRequest::release_leg_a_id() {
  // @@protoc_insertion_point(field_release:fs.BridgeCallRequest.leg_a_id)
  return _impl_.leg_a_id_.Release();
}
inline void BridgeCallRequest::set_allocated_leg_a_id(std::string* leg_a_id) {
  if (leg_a_id != nullptr) {
    
  } else {
    
  }
  _impl_.leg_a_id_.SetAllocated(leg_a_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leg_a_id_.IsDefault()) {
    _impl_.leg_a_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeCallRequest.leg_a_id)
}

// string leg_b_id = 2;
inline void BridgeCallRequest::clear_leg_b_id() {
  _impl_.leg_b_id_.ClearToEmpty();
}
inline const std::string& BridgeCallRequest::leg_b_id() const {
  // @@protoc_insertion_point(field_get:fs.BridgeCallRequest.leg_b_id)
  return _internal_leg_b_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BridgeCallRequest::set_leg_b_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leg_b_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BridgeCallRequest.leg_b_id)
}
inline std::string* BridgeCallRequest::mutable_leg_b_id() {
  std::string* _s = _internal_mutable_leg_b_id();
  // @@protoc_insertion_point(field_mutable:fs.BridgeCallRequest.leg_b_id)
  return _s;
}
inline const std::string& BridgeCallRequest::_internal_leg_b_id() const {
  return _impl_.leg_b_id_.Get();
}
inline void BridgeCallRequest::_internal_set_leg_b_id(const std::string& value) {
  
  _impl_.leg_b_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BridgeCallRequest::_internal_mutable_leg_b_id() {
  
  return _impl_.leg_b_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BridgeCallRequest::release_leg_b_id() {
  // @@protoc_insertion_point(field_release:fs.BridgeCallRequest.leg_b_id)
  return _impl_.leg_b_id_.Release();
}
inline void BridgeCallRequest::set_allocated_leg_b_id(std::string* leg_b_id) {
  if (leg_b_id != nullptr) {
    
  } else {
    
  }
  _impl_.leg_b_id_.SetAllocated(leg_b_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leg_b_id_.IsDefault()) {
    _impl_.leg_b_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeCallRequest.leg_b_id)
}

// map<string, string> variables = 3;
inline int BridgeCallRequest::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int BridgeCallRequest::variables_size() const {
  return _internal_variables_size();
}
inline void BridgeCallRequest::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BridgeCallRequest::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
BridgeCallRequest::variables() const {
  // @@protoc_insertion_point(field_map:fs.BridgeCallRequest.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BridgeCallRequest::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
BridgeCallRequest::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.BridgeCallRequest.variables)
  return _internal_mutable_variables();
}

// -------------------------------------------------------------------

// BridgeCallResponse

// string uuid = 1;
inline void BridgeCallResponse::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& BridgeCallResponse::uuid() const {
  // @@protoc_insertion_point(field_get:fs.BridgeCallResponse.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BridgeCallResponse::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BridgeCallResponse.uuid)
}
inline std::string* BridgeCallResponse::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:fs.BridgeCallResponse.uuid)
  return _s;
}
inline const std::string& BridgeCallResponse::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void BridgeCallResponse::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* BridgeCallResponse::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* BridgeCallResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:fs.BridgeCallResponse.uuid)
  return _impl_.uuid_.Release();
}
inline void BridgeCallResponse::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeCallResponse.uuid)
}

// .fs.ErrorExecute error = 2;
inline bool BridgeCallResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool BridgeCallResponse::has_error() const {
  return _internal_has_error();
}
inline void BridgeCallResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& BridgeCallResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& BridgeCallResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.BridgeCallResponse.error)
  return _internal_error();
}
inline void BridgeCallResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.BridgeCallResponse.error)
}
inline ::fs::ErrorExecute* BridgeCallResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* BridgeCallResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.BridgeCallResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* BridgeCallResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* BridgeCallResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.BridgeCallResponse.error)
  return _msg;
}
inline void BridgeCallResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeCallResponse.error)
}

// -------------------------------------------------------------------

// HoldRequest

// repeated string id = 1;
inline int HoldRequest::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int HoldRequest::id_size() const {
  return _internal_id_size();
}
inline void HoldRequest::clear_id() {
  _impl_.id_.Clear();
}
inline std::string* HoldRequest::add_id() {
  std::string* _s = _internal_add_id();
  // @@protoc_insertion_point(field_add_mutable:fs.HoldRequest.id)
  return _s;
}
inline const std::string& HoldRequest::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline const std::string& HoldRequest::id(int index) const {
  // @@protoc_insertion_point(field_get:fs.HoldRequest.id)
  return _internal_id(index);
}
inline std::string* HoldRequest::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:fs.HoldRequest.id)
  return _impl_.id_.Mutable(index);
}
inline void HoldRequest::set_id(int index, const std::string& value) {
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fs.HoldRequest.id)
}
inline void HoldRequest::set_id(int index, std::string&& value) {
  _impl_.id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fs.HoldRequest.id)
}
inline void HoldRequest::set_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fs.HoldRequest.id)
}
inline void HoldRequest::set_id(int index, const char* value, size_t size) {
  _impl_.id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fs.HoldRequest.id)
}
inline std::string* HoldRequest::_internal_add_id() {
  return _impl_.id_.Add();
}
inline void HoldRequest::add_id(const std::string& value) {
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fs.HoldRequest.id)
}
inline void HoldRequest::add_id(std::string&& value) {
  _impl_.id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fs.HoldRequest.id)
}
inline void HoldRequest::add_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fs.HoldRequest.id)
}
inline void HoldRequest::add_id(const char* value, size_t size) {
  _impl_.id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fs.HoldRequest.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HoldRequest::id() const {
  // @@protoc_insertion_point(field_list:fs.HoldRequest.id)
  return _impl_.id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HoldRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:fs.HoldRequest.id)
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// HoldResponse

// repeated string id = 1;
inline int HoldResponse::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int HoldResponse::id_size() const {
  return _internal_id_size();
}
inline void HoldResponse::clear_id() {
  _impl_.id_.Clear();
}
inline std::string* HoldResponse::add_id() {
  std::string* _s = _internal_add_id();
  // @@protoc_insertion_point(field_add_mutable:fs.HoldResponse.id)
  return _s;
}
inline const std::string& HoldResponse::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline const std::string& HoldResponse::id(int index) const {
  // @@protoc_insertion_point(field_get:fs.HoldResponse.id)
  return _internal_id(index);
}
inline std::string* HoldResponse::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:fs.HoldResponse.id)
  return _impl_.id_.Mutable(index);
}
inline void HoldResponse::set_id(int index, const std::string& value) {
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fs.HoldResponse.id)
}
inline void HoldResponse::set_id(int index, std::string&& value) {
  _impl_.id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fs.HoldResponse.id)
}
inline void HoldResponse::set_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fs.HoldResponse.id)
}
inline void HoldResponse::set_id(int index, const char* value, size_t size) {
  _impl_.id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fs.HoldResponse.id)
}
inline std::string* HoldResponse::_internal_add_id() {
  return _impl_.id_.Add();
}
inline void HoldResponse::add_id(const std::string& value) {
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fs.HoldResponse.id)
}
inline void HoldResponse::add_id(std::string&& value) {
  _impl_.id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fs.HoldResponse.id)
}
inline void HoldResponse::add_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fs.HoldResponse.id)
}
inline void HoldResponse::add_id(const char* value, size_t size) {
  _impl_.id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fs.HoldResponse.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HoldResponse::id() const {
  // @@protoc_insertion_point(field_list:fs.HoldResponse.id)
  return _impl_.id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HoldResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:fs.HoldResponse.id)
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// UnHoldRequest

// repeated string id = 1;
inline int UnHoldRequest::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int UnHoldRequest::id_size() const {
  return _internal_id_size();
}
inline void UnHoldRequest::clear_id() {
  _impl_.id_.Clear();
}
inline std::string* UnHoldRequest::add_id() {
  std::string* _s = _internal_add_id();
  // @@protoc_insertion_point(field_add_mutable:fs.UnHoldRequest.id)
  return _s;
}
inline const std::string& UnHoldRequest::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline const std::string& UnHoldRequest::id(int index) const {
  // @@protoc_insertion_point(field_get:fs.UnHoldRequest.id)
  return _internal_id(index);
}
inline std::string* UnHoldRequest::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:fs.UnHoldRequest.id)
  return _impl_.id_.Mutable(index);
}
inline void UnHoldRequest::set_id(int index, const std::string& value) {
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fs.UnHoldRequest.id)
}
inline void UnHoldRequest::set_id(int index, std::string&& value) {
  _impl_.id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fs.UnHoldRequest.id)
}
inline void UnHoldRequest::set_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fs.UnHoldRequest.id)
}
inline void UnHoldRequest::set_id(int index, const char* value, size_t size) {
  _impl_.id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fs.UnHoldRequest.id)
}
inline std::string* UnHoldRequest::_internal_add_id() {
  return _impl_.id_.Add();
}
inline void UnHoldRequest::add_id(const std::string& value) {
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fs.UnHoldRequest.id)
}
inline void UnHoldRequest::add_id(std::string&& value) {
  _impl_.id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fs.UnHoldRequest.id)
}
inline void UnHoldRequest::add_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fs.UnHoldRequest.id)
}
inline void UnHoldRequest::add_id(const char* value, size_t size) {
  _impl_.id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fs.UnHoldRequest.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UnHoldRequest::id() const {
  // @@protoc_insertion_point(field_list:fs.UnHoldRequest.id)
  return _impl_.id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UnHoldRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:fs.UnHoldRequest.id)
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// UnHoldResponse

// repeated string id = 1;
inline int UnHoldResponse::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int UnHoldResponse::id_size() const {
  return _internal_id_size();
}
inline void UnHoldResponse::clear_id() {
  _impl_.id_.Clear();
}
inline std::string* UnHoldResponse::add_id() {
  std::string* _s = _internal_add_id();
  // @@protoc_insertion_point(field_add_mutable:fs.UnHoldResponse.id)
  return _s;
}
inline const std::string& UnHoldResponse::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline const std::string& UnHoldResponse::id(int index) const {
  // @@protoc_insertion_point(field_get:fs.UnHoldResponse.id)
  return _internal_id(index);
}
inline std::string* UnHoldResponse::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:fs.UnHoldResponse.id)
  return _impl_.id_.Mutable(index);
}
inline void UnHoldResponse::set_id(int index, const std::string& value) {
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fs.UnHoldResponse.id)
}
inline void UnHoldResponse::set_id(int index, std::string&& value) {
  _impl_.id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fs.UnHoldResponse.id)
}
inline void UnHoldResponse::set_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fs.UnHoldResponse.id)
}
inline void UnHoldResponse::set_id(int index, const char* value, size_t size) {
  _impl_.id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fs.UnHoldResponse.id)
}
inline std::string* UnHoldResponse::_internal_add_id() {
  return _impl_.id_.Add();
}
inline void UnHoldResponse::add_id(const std::string& value) {
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fs.UnHoldResponse.id)
}
inline void UnHoldResponse::add_id(std::string&& value) {
  _impl_.id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fs.UnHoldResponse.id)
}
inline void UnHoldResponse::add_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fs.UnHoldResponse.id)
}
inline void UnHoldResponse::add_id(const char* value, size_t size) {
  _impl_.id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fs.UnHoldResponse.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UnHoldResponse::id() const {
  // @@protoc_insertion_point(field_list:fs.UnHoldResponse.id)
  return _impl_.id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UnHoldResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:fs.UnHoldResponse.id)
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// HangupManyRequest

// repeated string id = 1;
inline int HangupManyRequest::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int HangupManyRequest::id_size() const {
  return _internal_id_size();
}
inline void HangupManyRequest::clear_id() {
  _impl_.id_.Clear();
}
inline std::string* HangupManyRequest::add_id() {
  std::string* _s = _internal_add_id();
  // @@protoc_insertion_point(field_add_mutable:fs.HangupManyRequest.id)
  return _s;
}
inline const std::string& HangupManyRequest::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline const std::string& HangupManyRequest::id(int index) const {
  // @@protoc_insertion_point(field_get:fs.HangupManyRequest.id)
  return _internal_id(index);
}
inline std::string* HangupManyRequest::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:fs.HangupManyRequest.id)
  return _impl_.id_.Mutable(index);
}
inline void HangupManyRequest::set_id(int index, const std::string& value) {
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fs.HangupManyRequest.id)
}
inline void HangupManyRequest::set_id(int index, std::string&& value) {
  _impl_.id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fs.HangupManyRequest.id)
}
inline void HangupManyRequest::set_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fs.HangupManyRequest.id)
}
inline void HangupManyRequest::set_id(int index, const char* value, size_t size) {
  _impl_.id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fs.HangupManyRequest.id)
}
inline std::string* HangupManyRequest::_internal_add_id() {
  return _impl_.id_.Add();
}
inline void HangupManyRequest::add_id(const std::string& value) {
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fs.HangupManyRequest.id)
}
inline void HangupManyRequest::add_id(std::string&& value) {
  _impl_.id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fs.HangupManyRequest.id)
}
inline void HangupManyRequest::add_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fs.HangupManyRequest.id)
}
inline void HangupManyRequest::add_id(const char* value, size_t size) {
  _impl_.id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fs.HangupManyRequest.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HangupManyRequest::id() const {
  // @@protoc_insertion_point(field_list:fs.HangupManyRequest.id)
  return _impl_.id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HangupManyRequest::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:fs.HangupManyRequest.id)
  return &_impl_.id_;
}

// string cause = 2;
inline void HangupManyRequest::clear_cause() {
  _impl_.cause_.ClearToEmpty();
}
inline const std::string& HangupManyRequest::cause() const {
  // @@protoc_insertion_point(field_get:fs.HangupManyRequest.cause)
  return _internal_cause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HangupManyRequest::set_cause(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cause_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.HangupManyRequest.cause)
}
inline std::string* HangupManyRequest::mutable_cause() {
  std::string* _s = _internal_mutable_cause();
  // @@protoc_insertion_point(field_mutable:fs.HangupManyRequest.cause)
  return _s;
}
inline const std::string& HangupManyRequest::_internal_cause() const {
  return _impl_.cause_.Get();
}
inline void HangupManyRequest::_internal_set_cause(const std::string& value) {
  
  _impl_.cause_.Set(value, GetArenaForAllocation());
}
inline std::string* HangupManyRequest::_internal_mutable_cause() {
  
  return _impl_.cause_.Mutable(GetArenaForAllocation());
}
inline std::string* HangupManyRequest::release_cause() {
  // @@protoc_insertion_point(field_release:fs.HangupManyRequest.cause)
  return _impl_.cause_.Release();
}
inline void HangupManyRequest::set_allocated_cause(std::string* cause) {
  if (cause != nullptr) {
    
  } else {
    
  }
  _impl_.cause_.SetAllocated(cause, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cause_.IsDefault()) {
    _impl_.cause_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.HangupManyRequest.cause)
}

// -------------------------------------------------------------------

// HangupManyResponse

// repeated string id = 1;
inline int HangupManyResponse::_internal_id_size() const {
  return _impl_.id_.size();
}
inline int HangupManyResponse::id_size() const {
  return _internal_id_size();
}
inline void HangupManyResponse::clear_id() {
  _impl_.id_.Clear();
}
inline std::string* HangupManyResponse::add_id() {
  std::string* _s = _internal_add_id();
  // @@protoc_insertion_point(field_add_mutable:fs.HangupManyResponse.id)
  return _s;
}
inline const std::string& HangupManyResponse::_internal_id(int index) const {
  return _impl_.id_.Get(index);
}
inline const std::string& HangupManyResponse::id(int index) const {
  // @@protoc_insertion_point(field_get:fs.HangupManyResponse.id)
  return _internal_id(index);
}
inline std::string* HangupManyResponse::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:fs.HangupManyResponse.id)
  return _impl_.id_.Mutable(index);
}
inline void HangupManyResponse::set_id(int index, const std::string& value) {
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fs.HangupManyResponse.id)
}
inline void HangupManyResponse::set_id(int index, std::string&& value) {
  _impl_.id_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fs.HangupManyResponse.id)
}
inline void HangupManyResponse::set_id(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fs.HangupManyResponse.id)
}
inline void HangupManyResponse::set_id(int index, const char* value, size_t size) {
  _impl_.id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fs.HangupManyResponse.id)
}
inline std::string* HangupManyResponse::_internal_add_id() {
  return _impl_.id_.Add();
}
inline void HangupManyResponse::add_id(const std::string& value) {
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fs.HangupManyResponse.id)
}
inline void HangupManyResponse::add_id(std::string&& value) {
  _impl_.id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fs.HangupManyResponse.id)
}
inline void HangupManyResponse::add_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fs.HangupManyResponse.id)
}
inline void HangupManyResponse::add_id(const char* value, size_t size) {
  _impl_.id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fs.HangupManyResponse.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HangupManyResponse::id() const {
  // @@protoc_insertion_point(field_list:fs.HangupManyResponse.id)
  return _impl_.id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HangupManyResponse::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:fs.HangupManyResponse.id)
  return &_impl_.id_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// QueueRequest

// string id = 1;
inline void QueueRequest::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& QueueRequest::id() const {
  // @@protoc_insertion_point(field_get:fs.QueueRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueueRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.QueueRequest.id)
}
inline std::string* QueueRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:fs.QueueRequest.id)
  return _s;
}
inline const std::string& QueueRequest::_internal_id() const {
  return _impl_.id_.Get();
}
inline void QueueRequest::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* QueueRequest::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* QueueRequest::release_id() {
  // @@protoc_insertion_point(field_release:fs.QueueRequest.id)
  return _impl_.id_.Release();
}
inline void QueueRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.QueueRequest.id)
}

// map<string, string> variables = 2;
inline int QueueRequest::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int QueueRequest::variables_size() const {
  return _internal_variables_size();
}
inline void QueueRequest::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
QueueRequest::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
QueueRequest::variables() const {
  // @@protoc_insertion_point(field_map:fs.QueueRequest.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
QueueRequest::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
QueueRequest::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.QueueRequest.variables)
  return _internal_mutable_variables();
}

// string playback_file = 3;
inline void QueueRequest::clear_playback_file() {
  _impl_.playback_file_.ClearToEmpty();
}
inline const std::string& QueueRequest::playback_file() const {
  // @@protoc_insertion_point(field_get:fs.QueueRequest.playback_file)
  return _internal_playback_file();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QueueRequest::set_playback_file(ArgT0&& arg0, ArgT... args) {
 
 _impl_.playback_file_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.QueueRequest.playback_file)
}
inline std::string* QueueRequest::mutable_playback_file() {
  std::string* _s = _internal_mutable_playback_file();
  // @@protoc_insertion_point(field_mutable:fs.QueueRequest.playback_file)
  return _s;
}
inline const std::string& QueueRequest::_internal_playback_file() const {
  return _impl_.playback_file_.Get();
}
inline void QueueRequest::_internal_set_playback_file(const std::string& value) {
  
  _impl_.playback_file_.Set(value, GetArenaForAllocation());
}
inline std::string* QueueRequest::_internal_mutable_playback_file() {
  
  return _impl_.playback_file_.Mutable(GetArenaForAllocation());
}
inline std::string* QueueRequest::release_playback_file() {
  // @@protoc_insertion_point(field_release:fs.QueueRequest.playback_file)
  return _impl_.playback_file_.Release();
}
inline void QueueRequest::set_allocated_playback_file(std::string* playback_file) {
  if (playback_file != nullptr) {
    
  } else {
    
  }
  _impl_.playback_file_.SetAllocated(playback_file, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.playback_file_.IsDefault()) {
    _impl_.playback_file_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.QueueRequest.playback_file)
}

// int32 playback_args = 4;
inline void QueueRequest::clear_playback_args() {
  _impl_.playback_args_ = 0;
}
inline int32_t QueueRequest::_internal_playback_args() const {
  return _impl_.playback_args_;
}
inline int32_t QueueRequest::playback_args() const {
  // @@protoc_insertion_point(field_get:fs.QueueRequest.playback_args)
  return _internal_playback_args();
}
inline void QueueRequest::_internal_set_playback_args(int32_t value) {
  
  _impl_.playback_args_ = value;
}
inline void QueueRequest::set_playback_args(int32_t value) {
  _internal_set_playback_args(value);
  // @@protoc_insertion_point(field_set:fs.QueueRequest.playback_args)
}

// -------------------------------------------------------------------

// QueueResponse

// .fs.ErrorExecute error = 1;
inline bool QueueResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool QueueResponse::has_error() const {
  return _internal_has_error();
}
inline void QueueResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& QueueResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& QueueResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.QueueResponse.error)
  return _internal_error();
}
inline void QueueResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.QueueResponse.error)
}
inline ::fs::ErrorExecute* QueueResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* QueueResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.QueueResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* QueueResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* QueueResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.QueueResponse.error)
  return _msg;
}
inline void QueueResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.QueueResponse.error)
}

// -------------------------------------------------------------------

// ErrorExecute

// string message = 1;
inline void ErrorExecute::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ErrorExecute::message() const {
  // @@protoc_insertion_point(field_get:fs.ErrorExecute.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorExecute::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.ErrorExecute.message)
}
inline std::string* ErrorExecute::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:fs.ErrorExecute.message)
  return _s;
}
inline const std::string& ErrorExecute::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ErrorExecute::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorExecute::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorExecute::release_message() {
  // @@protoc_insertion_point(field_release:fs.ErrorExecute.message)
  return _impl_.message_.Release();
}
inline void ErrorExecute::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.ErrorExecute.message)
}

// .fs.ErrorExecute.Type type = 2;
inline void ErrorExecute::clear_type() {
  _impl_.type_ = 0;
}
inline ::fs::ErrorExecute_Type ErrorExecute::_internal_type() const {
  return static_cast< ::fs::ErrorExecute_Type >(_impl_.type_);
}
inline ::fs::ErrorExecute_Type ErrorExecute::type() const {
  // @@protoc_insertion_point(field_get:fs.ErrorExecute.type)
  return _internal_type();
}
inline void ErrorExecute::_internal_set_type(::fs::ErrorExecute_Type value) {
  
  _impl_.type_ = value;
}
inline void ErrorExecute::set_type(::fs::ErrorExecute_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:fs.ErrorExecute.type)
}

// -------------------------------------------------------------------

// ExecuteRequest

// string command = 1;
inline void ExecuteRequest::clear_command() {
  _impl_.command_.ClearToEmpty();
}
inline const std::string& ExecuteRequest::command() const {
  // @@protoc_insertion_point(field_get:fs.ExecuteRequest.command)
  return _internal_command();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteRequest::set_command(ArgT0&& arg0, ArgT... args) {
 
 _impl_.command_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.ExecuteRequest.command)
}
inline std::string* ExecuteRequest::mutable_command() {
  std::string* _s = _internal_mutable_command();
  // @@protoc_insertion_point(field_mutable:fs.ExecuteRequest.command)
  return _s;
}
inline const std::string& ExecuteRequest::_internal_command() const {
  return _impl_.command_.Get();
}
inline void ExecuteRequest::_internal_set_command(const std::string& value) {
  
  _impl_.command_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteRequest::_internal_mutable_command() {
  
  return _impl_.command_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteRequest::release_command() {
  // @@protoc_insertion_point(field_release:fs.ExecuteRequest.command)
  return _impl_.command_.Release();
}
inline void ExecuteRequest::set_allocated_command(std::string* command) {
  if (command != nullptr) {
    
  } else {
    
  }
  _impl_.command_.SetAllocated(command, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.command_.IsDefault()) {
    _impl_.command_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.ExecuteRequest.command)
}

// string args = 2;
inline void ExecuteRequest::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& ExecuteRequest::args() const {
  // @@protoc_insertion_point(field_get:fs.ExecuteRequest.args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteRequest::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.ExecuteRequest.args)
}
inline std::string* ExecuteRequest::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:fs.ExecuteRequest.args)
  return _s;
}
inline const std::string& ExecuteRequest::_internal_args() const {
  return _impl_.args_.Get();
}
inline void ExecuteRequest::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteRequest::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteRequest::release_args() {
  // @@protoc_insertion_point(field_release:fs.ExecuteRequest.args)
  return _impl_.args_.Release();
}
inline void ExecuteRequest::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.ExecuteRequest.args)
}

// -------------------------------------------------------------------

// ExecuteResponse

// string data = 1;
inline void ExecuteResponse::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ExecuteResponse::data() const {
  // @@protoc_insertion_point(field_get:fs.ExecuteResponse.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteResponse::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.ExecuteResponse.data)
}
inline std::string* ExecuteResponse::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:fs.ExecuteResponse.data)
  return _s;
}
inline const std::string& ExecuteResponse::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ExecuteResponse::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteResponse::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteResponse::release_data() {
  // @@protoc_insertion_point(field_release:fs.ExecuteResponse.data)
  return _impl_.data_.Release();
}
inline void ExecuteResponse::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.ExecuteResponse.data)
}

// .fs.ErrorExecute error = 2;
inline bool ExecuteResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool ExecuteResponse::has_error() const {
  return _internal_has_error();
}
inline void ExecuteResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& ExecuteResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& ExecuteResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.ExecuteResponse.error)
  return _internal_error();
}
inline void ExecuteResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.ExecuteResponse.error)
}
inline ::fs::ErrorExecute* ExecuteResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* ExecuteResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.ExecuteResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* ExecuteResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* ExecuteResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.ExecuteResponse.error)
  return _msg;
}
inline void ExecuteResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.ExecuteResponse.error)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HangupRequest

// string uuid = 1;
inline void HangupRequest::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& HangupRequest::uuid() const {
  // @@protoc_insertion_point(field_get:fs.HangupRequest.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HangupRequest::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.HangupRequest.uuid)
}
inline std::string* HangupRequest::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:fs.HangupRequest.uuid)
  return _s;
}
inline const std::string& HangupRequest::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void HangupRequest::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* HangupRequest::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* HangupRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:fs.HangupRequest.uuid)
  return _impl_.uuid_.Release();
}
inline void HangupRequest::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.HangupRequest.uuid)
}

// string cause = 2;
inline void HangupRequest::clear_cause() {
  _impl_.cause_.ClearToEmpty();
}
inline const std::string& HangupRequest::cause() const {
  // @@protoc_insertion_point(field_get:fs.HangupRequest.cause)
  return _internal_cause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HangupRequest::set_cause(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cause_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.HangupRequest.cause)
}
inline std::string* HangupRequest::mutable_cause() {
  std::string* _s = _internal_mutable_cause();
  // @@protoc_insertion_point(field_mutable:fs.HangupRequest.cause)
  return _s;
}
inline const std::string& HangupRequest::_internal_cause() const {
  return _impl_.cause_.Get();
}
inline void HangupRequest::_internal_set_cause(const std::string& value) {
  
  _impl_.cause_.Set(value, GetArenaForAllocation());
}
inline std::string* HangupRequest::_internal_mutable_cause() {
  
  return _impl_.cause_.Mutable(GetArenaForAllocation());
}
inline std::string* HangupRequest::release_cause() {
  // @@protoc_insertion_point(field_release:fs.HangupRequest.cause)
  return _impl_.cause_.Release();
}
inline void HangupRequest::set_allocated_cause(std::string* cause) {
  if (cause != nullptr) {
    
  } else {
    
  }
  _impl_.cause_.SetAllocated(cause, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cause_.IsDefault()) {
    _impl_.cause_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.HangupRequest.cause)
}

// bool reporting = 3;
inline void HangupRequest::clear_reporting() {
  _impl_.reporting_ = false;
}
inline bool HangupRequest::_internal_reporting() const {
  return _impl_.reporting_;
}
inline bool HangupRequest::reporting() const {
  // @@protoc_insertion_point(field_get:fs.HangupRequest.reporting)
  return _internal_reporting();
}
inline void HangupRequest::_internal_set_reporting(bool value) {
  
  _impl_.reporting_ = value;
}
inline void HangupRequest::set_reporting(bool value) {
  _internal_set_reporting(value);
  // @@protoc_insertion_point(field_set:fs.HangupRequest.reporting)
}

// map<string, string> variables = 4;
inline int HangupRequest::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int HangupRequest::variables_size() const {
  return _internal_variables_size();
}
inline void HangupRequest::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HangupRequest::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HangupRequest::variables() const {
  // @@protoc_insertion_point(field_map:fs.HangupRequest.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HangupRequest::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HangupRequest::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.HangupRequest.variables)
  return _internal_mutable_variables();
}

// -------------------------------------------------------------------

// HangupResponse

// .fs.ErrorExecute error = 1;
inline bool HangupResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool HangupResponse::has_error() const {
  return _internal_has_error();
}
inline void HangupResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& HangupResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& HangupResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.HangupResponse.error)
  return _internal_error();
}
inline void HangupResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.HangupResponse.error)
}
inline ::fs::ErrorExecute* HangupResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* HangupResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.HangupResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* HangupResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* HangupResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.HangupResponse.error)
  return _msg;
}
inline void HangupResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.HangupResponse.error)
}

// -------------------------------------------------------------------

// OriginateRequest_Extension

// string appName = 1;
inline void OriginateRequest_Extension::clear_appname() {
  _impl_.appname_.ClearToEmpty();
}
inline const std::string& OriginateRequest_Extension::appname() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.Extension.appName)
  return _internal_appname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateRequest_Extension::set_appname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.appname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.Extension.appName)
}
inline std::string* OriginateRequest_Extension::mutable_appname() {
  std::string* _s = _internal_mutable_appname();
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.Extension.appName)
  return _s;
}
inline const std::string& OriginateRequest_Extension::_internal_appname() const {
  return _impl_.appname_.Get();
}
inline void OriginateRequest_Extension::_internal_set_appname(const std::string& value) {
  
  _impl_.appname_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateRequest_Extension::_internal_mutable_appname() {
  
  return _impl_.appname_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateRequest_Extension::release_appname() {
  // @@protoc_insertion_point(field_release:fs.OriginateRequest.Extension.appName)
  return _impl_.appname_.Release();
}
inline void OriginateRequest_Extension::set_allocated_appname(std::string* appname) {
  if (appname != nullptr) {
    
  } else {
    
  }
  _impl_.appname_.SetAllocated(appname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.appname_.IsDefault()) {
    _impl_.appname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateRequest.Extension.appName)
}

// string args = 2;
inline void OriginateRequest_Extension::clear_args() {
  _impl_.args_.ClearToEmpty();
}
inline const std::string& OriginateRequest_Extension::args() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.Extension.args)
  return _internal_args();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateRequest_Extension::set_args(ArgT0&& arg0, ArgT... args) {
 
 _impl_.args_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.Extension.args)
}
inline std::string* OriginateRequest_Extension::mutable_args() {
  std::string* _s = _internal_mutable_args();
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.Extension.args)
  return _s;
}
inline const std::string& OriginateRequest_Extension::_internal_args() const {
  return _impl_.args_.Get();
}
inline void OriginateRequest_Extension::_internal_set_args(const std::string& value) {
  
  _impl_.args_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateRequest_Extension::_internal_mutable_args() {
  
  return _impl_.args_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateRequest_Extension::release_args() {
  // @@protoc_insertion_point(field_release:fs.OriginateRequest.Extension.args)
  return _impl_.args_.Release();
}
inline void OriginateRequest_Extension::set_allocated_args(std::string* args) {
  if (args != nullptr) {
    
  } else {
    
  }
  _impl_.args_.SetAllocated(args, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.args_.IsDefault()) {
    _impl_.args_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateRequest.Extension.args)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OriginateRequest

// map<string, string> variables = 1;
inline int OriginateRequest::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int OriginateRequest::variables_size() const {
  return _internal_variables_size();
}
inline void OriginateRequest::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OriginateRequest::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
OriginateRequest::variables() const {
  // @@protoc_insertion_point(field_map:fs.OriginateRequest.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OriginateRequest::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
OriginateRequest::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.OriginateRequest.variables)
  return _internal_mutable_variables();
}

// repeated string endpoints = 2;
inline int OriginateRequest::_internal_endpoints_size() const {
  return _impl_.endpoints_.size();
}
inline int OriginateRequest::endpoints_size() const {
  return _internal_endpoints_size();
}
inline void OriginateRequest::clear_endpoints() {
  _impl_.endpoints_.Clear();
}
inline std::string* OriginateRequest::add_endpoints() {
  std::string* _s = _internal_add_endpoints();
  // @@protoc_insertion_point(field_add_mutable:fs.OriginateRequest.endpoints)
  return _s;
}
inline const std::string& OriginateRequest::_internal_endpoints(int index) const {
  return _impl_.endpoints_.Get(index);
}
inline const std::string& OriginateRequest::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.endpoints)
  return _internal_endpoints(index);
}
inline std::string* OriginateRequest::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.endpoints)
  return _impl_.endpoints_.Mutable(index);
}
inline void OriginateRequest::set_endpoints(int index, const std::string& value) {
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.endpoints)
}
inline void OriginateRequest::set_endpoints(int index, std::string&& value) {
  _impl_.endpoints_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.endpoints)
}
inline void OriginateRequest::set_endpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:fs.OriginateRequest.endpoints)
}
inline void OriginateRequest::set_endpoints(int index, const char* value, size_t size) {
  _impl_.endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:fs.OriginateRequest.endpoints)
}
inline std::string* OriginateRequest::_internal_add_endpoints() {
  return _impl_.endpoints_.Add();
}
inline void OriginateRequest::add_endpoints(const std::string& value) {
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:fs.OriginateRequest.endpoints)
}
inline void OriginateRequest::add_endpoints(std::string&& value) {
  _impl_.endpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:fs.OriginateRequest.endpoints)
}
inline void OriginateRequest::add_endpoints(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:fs.OriginateRequest.endpoints)
}
inline void OriginateRequest::add_endpoints(const char* value, size_t size) {
  _impl_.endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:fs.OriginateRequest.endpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
OriginateRequest::endpoints() const {
  // @@protoc_insertion_point(field_list:fs.OriginateRequest.endpoints)
  return _impl_.endpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
OriginateRequest::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:fs.OriginateRequest.endpoints)
  return &_impl_.endpoints_;
}

// .fs.OriginateRequest.Strategy strategy = 3;
inline void OriginateRequest::clear_strategy() {
  _impl_.strategy_ = 0;
}
inline ::fs::OriginateRequest_Strategy OriginateRequest::_internal_strategy() const {
  return static_cast< ::fs::OriginateRequest_Strategy >(_impl_.strategy_);
}
inline ::fs::OriginateRequest_Strategy OriginateRequest::strategy() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.strategy)
  return _internal_strategy();
}
inline void OriginateRequest::_internal_set_strategy(::fs::OriginateRequest_Strategy value) {
  
  _impl_.strategy_ = value;
}
inline void OriginateRequest::set_strategy(::fs::OriginateRequest_Strategy value) {
  _internal_set_strategy(value);
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.strategy)
}

// string destination = 4;
inline void OriginateRequest::clear_destination() {
  _impl_.destination_.ClearToEmpty();
}
inline const std::string& OriginateRequest::destination() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.destination)
  return _internal_destination();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateRequest::set_destination(ArgT0&& arg0, ArgT... args) {
 
 _impl_.destination_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.destination)
}
inline std::string* OriginateRequest::mutable_destination() {
  std::string* _s = _internal_mutable_destination();
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.destination)
  return _s;
}
inline const std::string& OriginateRequest::_internal_destination() const {
  return _impl_.destination_.Get();
}
inline void OriginateRequest::_internal_set_destination(const std::string& value) {
  
  _impl_.destination_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateRequest::_internal_mutable_destination() {
  
  return _impl_.destination_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateRequest::release_destination() {
  // @@protoc_insertion_point(field_release:fs.OriginateRequest.destination)
  return _impl_.destination_.Release();
}
inline void OriginateRequest::set_allocated_destination(std::string* destination) {
  if (destination != nullptr) {
    
  } else {
    
  }
  _impl_.destination_.SetAllocated(destination, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.destination_.IsDefault()) {
    _impl_.destination_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateRequest.destination)
}

// int32 timeout = 5;
inline void OriginateRequest::clear_timeout() {
  _impl_.timeout_ = 0;
}
inline int32_t OriginateRequest::_internal_timeout() const {
  return _impl_.timeout_;
}
inline int32_t OriginateRequest::timeout() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.timeout)
  return _internal_timeout();
}
inline void OriginateRequest::_internal_set_timeout(int32_t value) {
  
  _impl_.timeout_ = value;
}
inline void OriginateRequest::set_timeout(int32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.timeout)
}

// string callerNumber = 6;
inline void OriginateRequest::clear_callernumber() {
  _impl_.callernumber_.ClearToEmpty();
}
inline const std::string& OriginateRequest::callernumber() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.callerNumber)
  return _internal_callernumber();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateRequest::set_callernumber(ArgT0&& arg0, ArgT... args) {
 
 _impl_.callernumber_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.callerNumber)
}
inline std::string* OriginateRequest::mutable_callernumber() {
  std::string* _s = _internal_mutable_callernumber();
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.callerNumber)
  return _s;
}
inline const std::string& OriginateRequest::_internal_callernumber() const {
  return _impl_.callernumber_.Get();
}
inline void OriginateRequest::_internal_set_callernumber(const std::string& value) {
  
  _impl_.callernumber_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateRequest::_internal_mutable_callernumber() {
  
  return _impl_.callernumber_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateRequest::release_callernumber() {
  // @@protoc_insertion_point(field_release:fs.OriginateRequest.callerNumber)
  return _impl_.callernumber_.Release();
}
inline void OriginateRequest::set_allocated_callernumber(std::string* callernumber) {
  if (callernumber != nullptr) {
    
  } else {
    
  }
  _impl_.callernumber_.SetAllocated(callernumber, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.callernumber_.IsDefault()) {
    _impl_.callernumber_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateRequest.callerNumber)
}

// string callerName = 7;
inline void OriginateRequest::clear_callername() {
  _impl_.callername_.ClearToEmpty();
}
inline const std::string& OriginateRequest::callername() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.callerName)
  return _internal_callername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateRequest::set_callername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.callername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.callerName)
}
inline std::string* OriginateRequest::mutable_callername() {
  std::string* _s = _internal_mutable_callername();
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.callerName)
  return _s;
}
inline const std::string& OriginateRequest::_internal_callername() const {
  return _impl_.callername_.Get();
}
inline void OriginateRequest::_internal_set_callername(const std::string& value) {
  
  _impl_.callername_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateRequest::_internal_mutable_callername() {
  
  return _impl_.callername_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateRequest::release_callername() {
  // @@protoc_insertion_point(field_release:fs.OriginateRequest.callerName)
  return _impl_.callername_.Release();
}
inline void OriginateRequest::set_allocated_callername(std::string* callername) {
  if (callername != nullptr) {
    
  } else {
    
  }
  _impl_.callername_.SetAllocated(callername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.callername_.IsDefault()) {
    _impl_.callername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateRequest.callerName)
}

// string context = 8;
inline void OriginateRequest::clear_context() {
  _impl_.context_.ClearToEmpty();
}
inline const std::string& OriginateRequest::context() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.context)
  return _internal_context();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateRequest::set_context(ArgT0&& arg0, ArgT... args) {
 
 _impl_.context_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.context)
}
inline std::string* OriginateRequest::mutable_context() {
  std::string* _s = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.context)
  return _s;
}
inline const std::string& OriginateRequest::_internal_context() const {
  return _impl_.context_.Get();
}
inline void OriginateRequest::_internal_set_context(const std::string& value) {
  
  _impl_.context_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateRequest::_internal_mutable_context() {
  
  return _impl_.context_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateRequest::release_context() {
  // @@protoc_insertion_point(field_release:fs.OriginateRequest.context)
  return _impl_.context_.Release();
}
inline void OriginateRequest::set_allocated_context(std::string* context) {
  if (context != nullptr) {
    
  } else {
    
  }
  _impl_.context_.SetAllocated(context, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.context_.IsDefault()) {
    _impl_.context_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateRequest.context)
}

// string dialplan = 9;
inline void OriginateRequest::clear_dialplan() {
  _impl_.dialplan_.ClearToEmpty();
}
inline const std::string& OriginateRequest::dialplan() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.dialplan)
  return _internal_dialplan();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateRequest::set_dialplan(ArgT0&& arg0, ArgT... args) {
 
 _impl_.dialplan_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.dialplan)
}
inline std::string* OriginateRequest::mutable_dialplan() {
  std::string* _s = _internal_mutable_dialplan();
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.dialplan)
  return _s;
}
inline const std::string& OriginateRequest::_internal_dialplan() const {
  return _impl_.dialplan_.Get();
}
inline void OriginateRequest::_internal_set_dialplan(const std::string& value) {
  
  _impl_.dialplan_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateRequest::_internal_mutable_dialplan() {
  
  return _impl_.dialplan_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateRequest::release_dialplan() {
  // @@protoc_insertion_point(field_release:fs.OriginateRequest.dialplan)
  return _impl_.dialplan_.Release();
}
inline void OriginateRequest::set_allocated_dialplan(std::string* dialplan) {
  if (dialplan != nullptr) {
    
  } else {
    
  }
  _impl_.dialplan_.SetAllocated(dialplan, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.dialplan_.IsDefault()) {
    _impl_.dialplan_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateRequest.dialplan)
}

// repeated .fs.OriginateRequest.Extension extensions = 10;
inline int OriginateRequest::_internal_extensions_size() const {
  return _impl_.extensions_.size();
}
inline int OriginateRequest::extensions_size() const {
  return _internal_extensions_size();
}
inline void OriginateRequest::clear_extensions() {
  _impl_.extensions_.Clear();
}
inline ::fs::OriginateRequest_Extension* OriginateRequest::mutable_extensions(int index) {
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.extensions)
  return _impl_.extensions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fs::OriginateRequest_Extension >*
OriginateRequest::mutable_extensions() {
  // @@protoc_insertion_point(field_mutable_list:fs.OriginateRequest.extensions)
  return &_impl_.extensions_;
}
inline const ::fs::OriginateRequest_Extension& OriginateRequest::_internal_extensions(int index) const {
  return _impl_.extensions_.Get(index);
}
inline const ::fs::OriginateRequest_Extension& OriginateRequest::extensions(int index) const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.extensions)
  return _internal_extensions(index);
}
inline ::fs::OriginateRequest_Extension* OriginateRequest::_internal_add_extensions() {
  return _impl_.extensions_.Add();
}
inline ::fs::OriginateRequest_Extension* OriginateRequest::add_extensions() {
  ::fs::OriginateRequest_Extension* _add = _internal_add_extensions();
  // @@protoc_insertion_point(field_add:fs.OriginateRequest.extensions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::fs::OriginateRequest_Extension >&
OriginateRequest::extensions() const {
  // @@protoc_insertion_point(field_list:fs.OriginateRequest.extensions)
  return _impl_.extensions_;
}

// string check_id = 11;
inline void OriginateRequest::clear_check_id() {
  _impl_.check_id_.ClearToEmpty();
}
inline const std::string& OriginateRequest::check_id() const {
  // @@protoc_insertion_point(field_get:fs.OriginateRequest.check_id)
  return _internal_check_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateRequest::set_check_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.check_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateRequest.check_id)
}
inline std::string* OriginateRequest::mutable_check_id() {
  std::string* _s = _internal_mutable_check_id();
  // @@protoc_insertion_point(field_mutable:fs.OriginateRequest.check_id)
  return _s;
}
inline const std::string& OriginateRequest::_internal_check_id() const {
  return _impl_.check_id_.Get();
}
inline void OriginateRequest::_internal_set_check_id(const std::string& value) {
  
  _impl_.check_id_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateRequest::_internal_mutable_check_id() {
  
  return _impl_.check_id_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateRequest::release_check_id() {
  // @@protoc_insertion_point(field_release:fs.OriginateRequest.check_id)
  return _impl_.check_id_.Release();
}
inline void OriginateRequest::set_allocated_check_id(std::string* check_id) {
  if (check_id != nullptr) {
    
  } else {
    
  }
  _impl_.check_id_.SetAllocated(check_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.check_id_.IsDefault()) {
    _impl_.check_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateRequest.check_id)
}

// -------------------------------------------------------------------

// OriginateResponse

// string uuid = 1;
inline void OriginateResponse::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& OriginateResponse::uuid() const {
  // @@protoc_insertion_point(field_get:fs.OriginateResponse.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OriginateResponse::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.OriginateResponse.uuid)
}
inline std::string* OriginateResponse::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:fs.OriginateResponse.uuid)
  return _s;
}
inline const std::string& OriginateResponse::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void OriginateResponse::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* OriginateResponse::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* OriginateResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:fs.OriginateResponse.uuid)
  return _impl_.uuid_.Release();
}
inline void OriginateResponse::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateResponse.uuid)
}

// .fs.ErrorExecute error = 2;
inline bool OriginateResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool OriginateResponse::has_error() const {
  return _internal_has_error();
}
inline void OriginateResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& OriginateResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& OriginateResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.OriginateResponse.error)
  return _internal_error();
}
inline void OriginateResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.OriginateResponse.error)
}
inline ::fs::ErrorExecute* OriginateResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* OriginateResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.OriginateResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* OriginateResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* OriginateResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.OriginateResponse.error)
  return _msg;
}
inline void OriginateResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.OriginateResponse.error)
}

// int32 error_code = 3;
inline void OriginateResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t OriginateResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t OriginateResponse::error_code() const {
  // @@protoc_insertion_point(field_get:fs.OriginateResponse.error_code)
  return _internal_error_code();
}
inline void OriginateResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void OriginateResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:fs.OriginateResponse.error_code)
}

// -------------------------------------------------------------------

// BridgeRequest

// string leg_a_id = 1;
inline void BridgeRequest::clear_leg_a_id() {
  _impl_.leg_a_id_.ClearToEmpty();
}
inline const std::string& BridgeRequest::leg_a_id() const {
  // @@protoc_insertion_point(field_get:fs.BridgeRequest.leg_a_id)
  return _internal_leg_a_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BridgeRequest::set_leg_a_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leg_a_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BridgeRequest.leg_a_id)
}
inline std::string* BridgeRequest::mutable_leg_a_id() {
  std::string* _s = _internal_mutable_leg_a_id();
  // @@protoc_insertion_point(field_mutable:fs.BridgeRequest.leg_a_id)
  return _s;
}
inline const std::string& BridgeRequest::_internal_leg_a_id() const {
  return _impl_.leg_a_id_.Get();
}
inline void BridgeRequest::_internal_set_leg_a_id(const std::string& value) {
  
  _impl_.leg_a_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BridgeRequest::_internal_mutable_leg_a_id() {
  
  return _impl_.leg_a_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BridgeRequest::release_leg_a_id() {
  // @@protoc_insertion_point(field_release:fs.BridgeRequest.leg_a_id)
  return _impl_.leg_a_id_.Release();
}
inline void BridgeRequest::set_allocated_leg_a_id(std::string* leg_a_id) {
  if (leg_a_id != nullptr) {
    
  } else {
    
  }
  _impl_.leg_a_id_.SetAllocated(leg_a_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leg_a_id_.IsDefault()) {
    _impl_.leg_a_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeRequest.leg_a_id)
}

// string leg_b_id = 2;
inline void BridgeRequest::clear_leg_b_id() {
  _impl_.leg_b_id_.ClearToEmpty();
}
inline const std::string& BridgeRequest::leg_b_id() const {
  // @@protoc_insertion_point(field_get:fs.BridgeRequest.leg_b_id)
  return _internal_leg_b_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BridgeRequest::set_leg_b_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leg_b_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BridgeRequest.leg_b_id)
}
inline std::string* BridgeRequest::mutable_leg_b_id() {
  std::string* _s = _internal_mutable_leg_b_id();
  // @@protoc_insertion_point(field_mutable:fs.BridgeRequest.leg_b_id)
  return _s;
}
inline const std::string& BridgeRequest::_internal_leg_b_id() const {
  return _impl_.leg_b_id_.Get();
}
inline void BridgeRequest::_internal_set_leg_b_id(const std::string& value) {
  
  _impl_.leg_b_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BridgeRequest::_internal_mutable_leg_b_id() {
  
  return _impl_.leg_b_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BridgeRequest::release_leg_b_id() {
  // @@protoc_insertion_point(field_release:fs.BridgeRequest.leg_b_id)
  return _impl_.leg_b_id_.Release();
}
inline void BridgeRequest::set_allocated_leg_b_id(std::string* leg_b_id) {
  if (leg_b_id != nullptr) {
    
  } else {
    
  }
  _impl_.leg_b_id_.SetAllocated(leg_b_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leg_b_id_.IsDefault()) {
    _impl_.leg_b_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeRequest.leg_b_id)
}

// string leg_b_reserve_id = 3;
inline void BridgeRequest::clear_leg_b_reserve_id() {
  _impl_.leg_b_reserve_id_.ClearToEmpty();
}
inline const std::string& BridgeRequest::leg_b_reserve_id() const {
  // @@protoc_insertion_point(field_get:fs.BridgeRequest.leg_b_reserve_id)
  return _internal_leg_b_reserve_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BridgeRequest::set_leg_b_reserve_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.leg_b_reserve_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BridgeRequest.leg_b_reserve_id)
}
inline std::string* BridgeRequest::mutable_leg_b_reserve_id() {
  std::string* _s = _internal_mutable_leg_b_reserve_id();
  // @@protoc_insertion_point(field_mutable:fs.BridgeRequest.leg_b_reserve_id)
  return _s;
}
inline const std::string& BridgeRequest::_internal_leg_b_reserve_id() const {
  return _impl_.leg_b_reserve_id_.Get();
}
inline void BridgeRequest::_internal_set_leg_b_reserve_id(const std::string& value) {
  
  _impl_.leg_b_reserve_id_.Set(value, GetArenaForAllocation());
}
inline std::string* BridgeRequest::_internal_mutable_leg_b_reserve_id() {
  
  return _impl_.leg_b_reserve_id_.Mutable(GetArenaForAllocation());
}
inline std::string* BridgeRequest::release_leg_b_reserve_id() {
  // @@protoc_insertion_point(field_release:fs.BridgeRequest.leg_b_reserve_id)
  return _impl_.leg_b_reserve_id_.Release();
}
inline void BridgeRequest::set_allocated_leg_b_reserve_id(std::string* leg_b_reserve_id) {
  if (leg_b_reserve_id != nullptr) {
    
  } else {
    
  }
  _impl_.leg_b_reserve_id_.SetAllocated(leg_b_reserve_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.leg_b_reserve_id_.IsDefault()) {
    _impl_.leg_b_reserve_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeRequest.leg_b_reserve_id)
}

// -------------------------------------------------------------------

// BridgeResponse

// string uuid = 1;
inline void BridgeResponse::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& BridgeResponse::uuid() const {
  // @@protoc_insertion_point(field_get:fs.BridgeResponse.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BridgeResponse::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.BridgeResponse.uuid)
}
inline std::string* BridgeResponse::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:fs.BridgeResponse.uuid)
  return _s;
}
inline const std::string& BridgeResponse::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void BridgeResponse::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* BridgeResponse::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* BridgeResponse::release_uuid() {
  // @@protoc_insertion_point(field_release:fs.BridgeResponse.uuid)
  return _impl_.uuid_.Release();
}
inline void BridgeResponse::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeResponse.uuid)
}

// .fs.ErrorExecute error = 2;
inline bool BridgeResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool BridgeResponse::has_error() const {
  return _internal_has_error();
}
inline void BridgeResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& BridgeResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& BridgeResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.BridgeResponse.error)
  return _internal_error();
}
inline void BridgeResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.BridgeResponse.error)
}
inline ::fs::ErrorExecute* BridgeResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* BridgeResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.BridgeResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* BridgeResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* BridgeResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.BridgeResponse.error)
  return _msg;
}
inline void BridgeResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.BridgeResponse.error)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SetVariablesRequest

// string uuid = 1;
inline void SetVariablesRequest::clear_uuid() {
  _impl_.uuid_.ClearToEmpty();
}
inline const std::string& SetVariablesRequest::uuid() const {
  // @@protoc_insertion_point(field_get:fs.SetVariablesRequest.uuid)
  return _internal_uuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SetVariablesRequest::set_uuid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.uuid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.SetVariablesRequest.uuid)
}
inline std::string* SetVariablesRequest::mutable_uuid() {
  std::string* _s = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:fs.SetVariablesRequest.uuid)
  return _s;
}
inline const std::string& SetVariablesRequest::_internal_uuid() const {
  return _impl_.uuid_.Get();
}
inline void SetVariablesRequest::_internal_set_uuid(const std::string& value) {
  
  _impl_.uuid_.Set(value, GetArenaForAllocation());
}
inline std::string* SetVariablesRequest::_internal_mutable_uuid() {
  
  return _impl_.uuid_.Mutable(GetArenaForAllocation());
}
inline std::string* SetVariablesRequest::release_uuid() {
  // @@protoc_insertion_point(field_release:fs.SetVariablesRequest.uuid)
  return _impl_.uuid_.Release();
}
inline void SetVariablesRequest::set_allocated_uuid(std::string* uuid) {
  if (uuid != nullptr) {
    
  } else {
    
  }
  _impl_.uuid_.SetAllocated(uuid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.uuid_.IsDefault()) {
    _impl_.uuid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.SetVariablesRequest.uuid)
}

// map<string, string> variables = 2;
inline int SetVariablesRequest::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int SetVariablesRequest::variables_size() const {
  return _internal_variables_size();
}
inline void SetVariablesRequest::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SetVariablesRequest::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SetVariablesRequest::variables() const {
  // @@protoc_insertion_point(field_map:fs.SetVariablesRequest.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SetVariablesRequest::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SetVariablesRequest::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.SetVariablesRequest.variables)
  return _internal_mutable_variables();
}

// -------------------------------------------------------------------

// SetVariablesResponse

// .fs.ErrorExecute error = 1;
inline bool SetVariablesResponse::_internal_has_error() const {
  return this != internal_default_instance() && _impl_.error_ != nullptr;
}
inline bool SetVariablesResponse::has_error() const {
  return _internal_has_error();
}
inline void SetVariablesResponse::clear_error() {
  if (GetArenaForAllocation() == nullptr && _impl_.error_ != nullptr) {
    delete _impl_.error_;
  }
  _impl_.error_ = nullptr;
}
inline const ::fs::ErrorExecute& SetVariablesResponse::_internal_error() const {
  const ::fs::ErrorExecute* p = _impl_.error_;
  return p != nullptr ? *p : reinterpret_cast<const ::fs::ErrorExecute&>(
      ::fs::_ErrorExecute_default_instance_);
}
inline const ::fs::ErrorExecute& SetVariablesResponse::error() const {
  // @@protoc_insertion_point(field_get:fs.SetVariablesResponse.error)
  return _internal_error();
}
inline void SetVariablesResponse::unsafe_arena_set_allocated_error(
    ::fs::ErrorExecute* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.error_);
  }
  _impl_.error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:fs.SetVariablesResponse.error)
}
inline ::fs::ErrorExecute* SetVariablesResponse::release_error() {
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::fs::ErrorExecute* SetVariablesResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:fs.SetVariablesResponse.error)
  
  ::fs::ErrorExecute* temp = _impl_.error_;
  _impl_.error_ = nullptr;
  return temp;
}
inline ::fs::ErrorExecute* SetVariablesResponse::_internal_mutable_error() {
  
  if (_impl_.error_ == nullptr) {
    auto* p = CreateMaybeMessage<::fs::ErrorExecute>(GetArenaForAllocation());
    _impl_.error_ = p;
  }
  return _impl_.error_;
}
inline ::fs::ErrorExecute* SetVariablesResponse::mutable_error() {
  ::fs::ErrorExecute* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:fs.SetVariablesResponse.error)
  return _msg;
}
inline void SetVariablesResponse::set_allocated_error(::fs::ErrorExecute* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.error_ = error;
  // @@protoc_insertion_point(field_set_allocated:fs.SetVariablesResponse.error)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// HangupMatchingVarsReqeust

// string cause = 1;
inline void HangupMatchingVarsReqeust::clear_cause() {
  _impl_.cause_.ClearToEmpty();
}
inline const std::string& HangupMatchingVarsReqeust::cause() const {
  // @@protoc_insertion_point(field_get:fs.HangupMatchingVarsReqeust.cause)
  return _internal_cause();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HangupMatchingVarsReqeust::set_cause(ArgT0&& arg0, ArgT... args) {
 
 _impl_.cause_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:fs.HangupMatchingVarsReqeust.cause)
}
inline std::string* HangupMatchingVarsReqeust::mutable_cause() {
  std::string* _s = _internal_mutable_cause();
  // @@protoc_insertion_point(field_mutable:fs.HangupMatchingVarsReqeust.cause)
  return _s;
}
inline const std::string& HangupMatchingVarsReqeust::_internal_cause() const {
  return _impl_.cause_.Get();
}
inline void HangupMatchingVarsReqeust::_internal_set_cause(const std::string& value) {
  
  _impl_.cause_.Set(value, GetArenaForAllocation());
}
inline std::string* HangupMatchingVarsReqeust::_internal_mutable_cause() {
  
  return _impl_.cause_.Mutable(GetArenaForAllocation());
}
inline std::string* HangupMatchingVarsReqeust::release_cause() {
  // @@protoc_insertion_point(field_release:fs.HangupMatchingVarsReqeust.cause)
  return _impl_.cause_.Release();
}
inline void HangupMatchingVarsReqeust::set_allocated_cause(std::string* cause) {
  if (cause != nullptr) {
    
  } else {
    
  }
  _impl_.cause_.SetAllocated(cause, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.cause_.IsDefault()) {
    _impl_.cause_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:fs.HangupMatchingVarsReqeust.cause)
}

// map<string, string> variables = 2;
inline int HangupMatchingVarsReqeust::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int HangupMatchingVarsReqeust::variables_size() const {
  return _internal_variables_size();
}
inline void HangupMatchingVarsReqeust::clear_variables() {
  _impl_.variables_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HangupMatchingVarsReqeust::_internal_variables() const {
  return _impl_.variables_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
HangupMatchingVarsReqeust::variables() const {
  // @@protoc_insertion_point(field_map:fs.HangupMatchingVarsReqeust.variables)
  return _internal_variables();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HangupMatchingVarsReqeust::_internal_mutable_variables() {
  return _impl_.variables_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
HangupMatchingVarsReqeust::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_map:fs.HangupMatchingVarsReqeust.variables)
  return _internal_mutable_variables();
}

// -------------------------------------------------------------------

// HangupMatchingVarsResponse

// int32 count = 1;
inline void HangupMatchingVarsResponse::clear_count() {
  _impl_.count_ = 0;
}
inline int32_t HangupMatchingVarsResponse::_internal_count() const {
  return _impl_.count_;
}
inline int32_t HangupMatchingVarsResponse::count() const {
  // @@protoc_insertion_point(field_get:fs.HangupMatchingVarsResponse.count)
  return _internal_count();
}
inline void HangupMatchingVarsResponse::_internal_set_count(int32_t value) {
  
  _impl_.count_ = value;
}
inline void HangupMatchingVarsResponse::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:fs.HangupMatchingVarsResponse.count)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fs

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::fs::ErrorExecute_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fs::ErrorExecute_Type>() {
  return ::fs::ErrorExecute_Type_descriptor();
}
template <> struct is_proto_enum< ::fs::OriginateRequest_Strategy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fs::OriginateRequest_Strategy>() {
  return ::fs::OriginateRequest_Strategy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_fs_2eproto
